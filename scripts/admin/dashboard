#!/usr/bin/env python3
"""
DS01 Unified Dashboard - Comprehensive system monitoring

Usage:
  dashboard                    # Default snapshot view
  dashboard --full             # All sections expanded
  dashboard --temp             # Thermal/power info only
  dashboard mig-status         # MIG configuration details
  dashboard util               # Utilization metrics
  dashboard container [name]   # Container-specific view
  dashboard users              # Per-user summary
  dashboard allocations [N]    # Recent N allocations (default 10)
  dashboard monitor            # Continuous watch mode (1s refresh)
"""

import sys
import os
import json
import subprocess
import argparse
import time
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import importlib.util

# Add script directory to path
SCRIPT_DIR = Path(__file__).parent
INFRA_ROOT = SCRIPT_DIR.parent.parent
sys.path.insert(0, str(INFRA_ROOT / "scripts" / "docker"))

# Import helper modules
spec = importlib.util.spec_from_file_location('gpu_state_reader', str(INFRA_ROOT / 'scripts' / 'docker' / 'gpu-state-reader.py'))
gpu_state_module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(gpu_state_module)
GPUStateReader = gpu_state_module.GPUStateReader

spec = importlib.util.spec_from_file_location('gpu_allocator_v2', str(INFRA_ROOT / 'scripts' / 'docker' / 'gpu_allocator_v2.py'))
gpu_alloc_module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(gpu_alloc_module)
GPUAllocatorSmart = gpu_alloc_module.GPUAllocatorSmart

# ANSI Color codes
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    GRAY = '\033[90m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

    @staticmethod
    def colorize(text: str, color: str) -> str:
        return f"{color}{text}{Colors.RESET}"


class DashboardData:
    """Single source of truth data fetcher - reads from Docker only"""

    def __init__(self):
        self.state_reader = GPUStateReader()
        self.allocator = GPUAllocatorSmart()
        self.config_file = INFRA_ROOT / "config" / "resource-limits.yaml"

    def get_gpu_overview(self) -> Dict:
        """Get GPU allocation overview"""
        status = self.allocator.get_status()

        # Get MIG configuration details
        mig_info = self._get_mig_configuration()

        return {
            'total_gpus': status['total_gpus'],
            'allocated': status['allocated'],
            'available': status['available'],
            'utilization_percent': status['utilization_percent'],
            'allocations': status['allocations'],
            'mig_config': mig_info
        }

    def _get_mig_configuration(self) -> Dict:
        """Get MIG partitioning details from nvidia-smi"""
        try:
            result = subprocess.run(
                ['nvidia-smi', 'mig', '-lgi'],
                capture_output=True, text=True, check=True
            )

            # Parse MIG instances
            mig_instances = {}
            current_gpu = None

            for line in result.stdout.split('\n'):
                if line.strip().startswith('GPU '):
                    parts = line.split()
                    if len(parts) >= 2:
                        current_gpu = parts[1].rstrip(':')
                        mig_instances[current_gpu] = []
                elif current_gpu and '|' in line and 'MIG' in line:
                    # Parse MIG instance line
                    parts = [p.strip() for p in line.split('|')]
                    if len(parts) >= 3:
                        mig_instances[current_gpu].append({
                            'id': parts[0],
                            'profile': parts[1] if len(parts) > 1 else 'unknown',
                            'instance': parts[2] if len(parts) > 2 else 'unknown'
                        })

            return mig_instances
        except (subprocess.CalledProcessError, Exception):
            return {}

    def get_container_summary(self) -> Dict:
        """Get container status summary"""
        try:
            # Get all DS01-managed containers (have aime.mlc.USER label)
            result = subprocess.run(
                ['docker', 'ps', '-a', '--filter', 'label=aime.mlc.USER', '--format',
                 '{{.Names}}\t{{.Status}}\t{{index .Config.Labels "aime.mlc.USER"}}\t{{.CreatedAt}}'],
                capture_output=True, text=True, check=True
            )

            running = []
            stopped = []

            for line in result.stdout.strip().split('\n'):
                if not line:
                    continue

                parts = line.split('\t')
                if len(parts) >= 4:
                    name, status, user, created = parts[0], parts[1], parts[2], parts[3]

                    # Get container stats if running
                    stats = None
                    if 'Up' in status:
                        stats = self._get_container_stats(name)

                    # Get GPU allocation
                    gpu_info = self.state_reader.get_container_gpu(name)
                    gpu_slot = gpu_info['gpu_slot'] if gpu_info else None

                    container_data = {
                        'name': name,
                        'status': status,
                        'user': user,
                        'gpu': gpu_slot,
                        'stats': stats,
                        'created': created
                    }

                    if 'Up' in status:
                        running.append(container_data)
                    else:
                        stopped.append(container_data)

            return {
                'running': running,
                'stopped': stopped,
                'total': len(running) + len(stopped)
            }
        except subprocess.CalledProcessError:
            return {'running': [], 'stopped': [], 'total': 0}

    def _get_container_stats(self, container: str) -> Optional[Dict]:
        """Get real-time stats for a container"""
        try:
            result = subprocess.run(
                ['docker', 'stats', container, '--no-stream', '--format',
                 '{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}'],
                capture_output=True, text=True, check=True, timeout=2
            )

            parts = result.stdout.strip().split('\t')
            if len(parts) >= 4:
                return {
                    'cpu': parts[0],
                    'mem': parts[1],
                    'net': parts[2],
                    'block': parts[3]
                }
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            pass
        return None

    def get_user_summary(self) -> Dict:
        """Get per-user resource usage"""
        containers = self.get_container_summary()

        user_stats = {}
        for container in containers['running'] + containers['stopped']:
            user = container['user']
            if user not in user_stats:
                user_stats[user] = {
                    'containers': 0,
                    'running': 0,
                    'stopped': 0,
                    'gpus': []
                }

            user_stats[user]['containers'] += 1
            if 'Up' in container['status']:
                user_stats[user]['running'] += 1
            else:
                user_stats[user]['stopped'] += 1

            if container['gpu']:
                user_stats[user]['gpus'].append(container['gpu'])

        return user_stats

    def get_system_resources(self) -> Dict:
        """Get system resource usage"""
        # CPU info
        try:
            with open('/proc/cpuinfo', 'r') as f:
                cpu_count = len([line for line in f if line.startswith('processor')])

            with open('/proc/loadavg', 'r') as f:
                load = float(f.read().split()[0])
                cpu_percent = (load / cpu_count) * 100
        except:
            cpu_count = 0
            cpu_percent = 0

        # Memory info
        try:
            with open('/proc/meminfo', 'r') as f:
                meminfo = {}
                for line in f:
                    parts = line.split(':')
                    if len(parts) == 2:
                        meminfo[parts[0].strip()] = parts[1].strip()

            total_mem = int(meminfo.get('MemTotal', '0').split()[0]) / (1024 * 1024)  # GB
            available_mem = int(meminfo.get('MemAvailable', '0').split()[0]) / (1024 * 1024)  # GB
            used_mem = total_mem - available_mem
            mem_percent = (used_mem / total_mem * 100) if total_mem > 0 else 0
        except:
            total_mem = used_mem = mem_percent = 0

        # Disk info
        try:
            result = subprocess.run(['df', '-BG', '/'], capture_output=True, text=True, check=True)
            lines = result.stdout.strip().split('\n')
            if len(lines) >= 2:
                parts = lines[1].split()
                total_disk = int(parts[1].rstrip('G'))
                used_disk = int(parts[2].rstrip('G'))
                disk_percent = int(parts[4].rstrip('%'))
            else:
                total_disk = used_disk = disk_percent = 0
        except:
            total_disk = used_disk = disk_percent = 0

        return {
            'cpu': {'count': cpu_count, 'percent': cpu_percent},
            'memory': {'total': total_mem, 'used': used_mem, 'percent': mem_percent},
            'disk': {'total': total_disk, 'used': used_disk, 'percent': disk_percent}
        }

    def get_recent_allocations(self, limit: int = 10) -> List[Dict]:
        """Get recent GPU allocations from log"""
        log_file = Path('/var/log/ds01/gpu-allocations.log')

        if not log_file.exists():
            return []

        allocations = []
        try:
            with open(log_file, 'r') as f:
                lines = f.readlines()

            # Parse last N lines
            for line in reversed(lines[-limit*2:]):  # Read more than needed to filter
                if 'ALLOCATED' in line or 'REJECTED' in line:
                    parts = line.split('|')
                    if len(parts) >= 6:
                        allocations.append({
                            'timestamp': parts[0],
                            'event': parts[1],
                            'user': parts[2],
                            'container': parts[3],
                            'gpu': parts[4],
                            'reason': parts[6] if len(parts) > 6 else ''
                        })

                        if len(allocations) >= limit:
                            break
        except Exception:
            pass

        return list(reversed(allocations))[:limit]

    def get_unmanaged_containers(self) -> List[Dict]:
        """Get containers without DS01 labels (created with direct docker commands)"""
        try:
            # Get all containers
            result = subprocess.run(
                ['docker', 'ps', '-a', '--format', '{{.Names}}\t{{.Status}}\t{{.Image}}'],
                capture_output=True, text=True, check=True
            )
            all_containers = set(line.split('\t')[0] for line in result.stdout.strip().split('\n') if line)

            # Get DS01-managed containers
            result = subprocess.run(
                ['docker', 'ps', '-a', '--filter', 'label=aime.mlc.USER', '--format', '{{.Names}}'],
                capture_output=True, text=True, check=True
            )
            managed = set(line.strip() for line in result.stdout.strip().split('\n') if line)

            # Unmanaged = all - managed
            unmanaged_names = all_containers - managed

            unmanaged = []
            for name in unmanaged_names:
                result = subprocess.run(
                    ['docker', 'ps', '-a', '--filter', f'name={name}', '--format',
                     '{{.Names}}\t{{.Status}}\t{{.Image}}'],
                    capture_output=True, text=True, check=True
                )
                if result.stdout.strip():
                    parts = result.stdout.strip().split('\t')
                    if len(parts) >= 3:
                        unmanaged.append({
                            'name': parts[0],
                            'status': parts[1],
                            'image': parts[2]
                        })

            return unmanaged
        except subprocess.CalledProcessError:
            return []


class DashboardView:
    """Visual rendering with color coding"""

    def __init__(self, data: DashboardData):
        self.data = data

    def render_default_view(self):
        """Render default snapshot view"""
        gpu_data = self.data.get_gpu_overview()
        container_data = self.data.get_container_summary()
        system_data = self.data.get_system_resources()
        recent_allocs = self.data.get_recent_allocations(10)
        unmanaged = self.data.get_unmanaged_containers()

        # Header
        print("â•" * 65)
        print(Colors.colorize("                    DS01 GPU SERVER STATUS", Colors.BOLD))
        print("â•" * 65)
        print()

        # GPU Section
        self._render_gpu_section(gpu_data)
        print()

        # System Resources
        self._render_system_resources(system_data)
        print()

        # Containers
        self._render_container_section(container_data)
        print()

        # Alerts
        alerts = self._get_alerts(container_data, unmanaged)
        if alerts:
            print(Colors.colorize("âš ï¸  ALERTS", Colors.YELLOW))
            for alert in alerts:
                print(f"â€¢ {alert}")
            print()

        # Recent allocations
        if recent_allocs:
            print(Colors.colorize("ðŸ“œ RECENT ALLOCATIONS (last 10)", Colors.BLUE))
            for alloc in recent_allocs:
                timestamp = alloc['timestamp'].strip().split()[1]  # Get time only
                event_color = Colors.GREEN if alloc['event'] == 'ALLOCATED' else Colors.RED
                event_symbol = "â†’" if alloc['event'] == 'ALLOCATED' else "âœ—"
                gpu_str = alloc['gpu'] if alloc['gpu'] != 'N/A' else '-'
                print(f"  {timestamp}  {Colors.colorize(alloc['user'], Colors.BLUE)} {event_symbol} GPU {gpu_str}  {alloc['container']}")
            print()

        # Quick actions
        print(Colors.colorize("ðŸ’¡ Quick Actions:", Colors.BLUE))
        print("  dashboard --full              # See all details")
        print("  dashboard users               # Per-user breakdown")
        print("  dashboard monitor             # Watch mode (1s refresh)")
        print()

    def _render_gpu_section(self, gpu_data: Dict):
        """Render GPU allocation section"""
        allocated = gpu_data['allocated']
        total = gpu_data['total_gpus']
        util_pct = gpu_data['utilization_percent']

        header = f"ðŸŽ® GPU / MIG ALLOCATION{' ' * 27}[{allocated}/{total} allocated]"
        print(Colors.colorize(header, Colors.BOLD))
        print("â”Œ" + "â”€" * 63 + "â”")

        allocations = gpu_data['allocations']

        # Group by physical GPU
        gpus = {}
        for slot, info in allocations.items():
            parts = slot.split('.')
            gpu_id = parts[0]
            if gpu_id not in gpus:
                gpus[gpu_id] = {}
            gpus[gpu_id][slot] = info

        for gpu_id in sorted(gpus.keys(), key=lambda x: int(x)):
            slots = gpus[gpu_id]

            # Check if MIG or full GPU
            is_mig = any('.' in slot for slot in slots.keys())

            if is_mig:
                # MIG GPU
                mig_count = len(slots)
                profile = "1g.10gb"  # TODO: Get from config
                print(f"â”‚ GPU {gpu_id}  [MIG {profile}Ã—{mig_count}]" + " " * (63 - 22 - len(gpu_id) - len(str(mig_count))) + "â”‚")

                for slot in sorted(slots.keys(), key=lambda x: float(x)):
                    info = slots[slot]
                    if info['containers']:
                        container = info['containers'][0]
                        # Get container status
                        status = Colors.colorize("[ACTIVE]", Colors.GREEN)  # TODO: Check actual status
                        vram_bar = "â–ˆ" * 8 + "â”€" * 2
                        vram_pct = "80%"  # TODO: Get actual VRAM usage
                        print(f"â”‚   â”œâ”€ {slot}  {container:20s} {vram_bar} {vram_pct} VRAM  {status}  â”‚")
                    else:
                        avail = Colors.colorize("â”" * 10 + " AVAILABLE", Colors.GREEN)
                        print(f"â”‚   â””â”€ {slot}                    {avail + ' ' * 19}â”‚")
            else:
                # Full GPU
                slot = gpu_id
                info = slots.get(slot, {'containers': []})
                if info['containers']:
                    container = info['containers'][0]
                    print(f"â”‚ GPU {gpu_id}  [FULL GPU]           {container:20s} " + Colors.colorize("[ALLOCATED]", Colors.GREEN) + " â”‚")
                else:
                    avail = Colors.colorize("â”" * 10 + " AVAILABLE", Colors.GREEN)
                    print(f"â”‚ GPU {gpu_id}  [FULL GPU]           {avail + ' ' * 15}â”‚")

        print("â””" + "â”€" * 63 + "â”˜")

    def _render_system_resources(self, system_data: Dict):
        """Render system resource usage"""
        print(Colors.colorize("ðŸ“Š SYSTEM RESOURCES", Colors.BOLD))

        # CPU
        cpu = system_data['cpu']
        cpu_used = int(cpu['percent'] / 100 * cpu['count'])
        cpu_bar = self._progress_bar(cpu['percent'], 40)
        print(f"CPU:  {cpu_used}/{cpu['count']} cores ({cpu['percent']:.0f}%)  {cpu_bar}")

        # RAM
        mem = system_data['memory']
        mem_bar = self._progress_bar(mem['percent'], 40)
        print(f"RAM:  {mem['used']:.0f}/{mem['total']:.0f} GB  ({mem['percent']:.0f}%)  {mem_bar}")

        # Disk
        disk = system_data['disk']
        disk_bar = self._progress_bar(disk['percent'], 40)
        print(f"Disk: {disk['used']}/{disk['total']} GB  ({disk['percent']}%)  {disk_bar}")

    def _progress_bar(self, percent: float, width: int = 20) -> str:
        """Create ASCII progress bar"""
        filled = int(width * percent / 100)
        empty = width - filled
        return "â–ˆ" * filled + "â”€" * empty

    def _render_container_section(self, container_data: Dict):
        """Render container summary"""
        running_count = len(container_data['running'])
        stopped_count = len(container_data['stopped'])

        header = f"ðŸ“¦ CONTAINERS{' ' * 40}[{running_count} running, {stopped_count} stopped]"
        print(Colors.colorize(header, Colors.BOLD))
        print("â”Œ" + "â”€" * 63 + "â”")

        # Show running containers (limit to 5)
        if running_count > 0:
            print(f"â”‚ {Colors.colorize('RUNNING (' + str(running_count) + ')', Colors.GREEN) + ' ' * (62 - 10 - len(str(running_count)))}â”‚")
            for i, container in enumerate(container_data['running'][:5]):
                name = container['name']
                gpu = container['gpu'] if container['gpu'] else '-'
                stats = container['stats']
                cpu = stats['cpu'] if stats else '?%'
                mem = stats['mem'].split('/')[0] if stats else '?GB'

                # Calculate runtime
                # TODO: Parse created timestamp properly
                runtime = "?h ?m"

                # Check if idle
                is_idle = False
                if stats:
                    cpu_val = float(cpu.rstrip('%'))
                    is_idle = cpu_val < 1.0

                idle_warning = Colors.colorize(" âš ï¸ ", Colors.YELLOW) if is_idle else "   "

                line = f"â”‚   {name:20s} {gpu:4s}  CPU:{cpu:5s} RAM:{mem:8s} [{runtime}]{idle_warning}â”‚"
                print(line[:66] + "â”‚")

            if running_count > 5:
                print(f"â”‚   ... ({running_count - 5} more){' ' * 46}â”‚")

        # Show stopped containers (limit to 3)
        if stopped_count > 0:
            print(f"â”‚{' ' * 63}â”‚")
            print(f"â”‚ {Colors.colorize('STOPPED (' + str(stopped_count) + ')', Colors.GRAY) + ' ' * (62 - 10 - len(str(stopped_count)))}â”‚")
            for i, container in enumerate(container_data['stopped'][:3]):
                name = container['name']
                status = "Stopped recently"  # TODO: Calculate time ago
                line = f"â”‚   {name:20s} -     {status:30s} â”‚"
                print(line[:66] + "â”‚")

        print("â””" + "â”€" * 63 + "â”˜")

    def _get_alerts(self, container_data: Dict, unmanaged: List[Dict]) -> List[str]:
        """Generate alerts"""
        alerts = []

        # Check for idle containers
        for container in container_data['running']:
            if container['stats']:
                cpu_val = float(container['stats']['cpu'].rstrip('%'))
                if cpu_val < 1.0:
                    alerts.append(f"Container {container['name']} idle (CPU < 1%)")

        # Check for unmanaged containers
        if unmanaged:
            alerts.append(f"{len(unmanaged)} unmanaged containers detected (not tracked by DS01)")

        return alerts[:5]  # Limit to 5 alerts

    def render_users_view(self):
        """Render per-user summary"""
        user_stats = self.data.get_user_summary()

        print("â•" * 65)
        print(Colors.colorize("                    DS01 USER SUMMARY", Colors.BOLD))
        print("â•" * 65)
        print()

        print(f"{'User':<20} {'Containers':<12} {'Running':<10} {'GPUs':<10}")
        print("â”€" * 65)

        for user in sorted(user_stats.keys()):
            stats = user_stats[user]
            gpu_count = len(stats['gpus'])
            gpu_list = ', '.join(stats['gpus'][:3])
            if gpu_count > 3:
                gpu_list += f" +{gpu_count-3}"

            print(f"{user:<20} {stats['containers']:<12} {stats['running']:<10} {gpu_list:<10}")

        print()

    def render_allocations_view(self, limit: int):
        """Render allocation history"""
        allocations = self.data.get_recent_allocations(limit)

        print("â•" * 65)
        print(Colors.colorize(f"                GPU ALLOCATION HISTORY (last {limit})", Colors.BOLD))
        print("â•" * 65)
        print()

        for alloc in allocations:
            timestamp = alloc['timestamp'].strip()
            event = alloc['event']
            user = alloc['user']
            container = alloc['container']
            gpu = alloc['gpu']
            reason = alloc['reason']

            event_color = Colors.GREEN if event == 'ALLOCATED' else Colors.RED
            event_symbol = "âœ“" if event == 'ALLOCATED' else "âœ—"

            print(f"{timestamp} {Colors.colorize(event_symbol, event_color)} {user:<15} {container:<20} GPU:{gpu:<8} {reason}")

        print()


def main():
    parser = argparse.ArgumentParser(
        description='DS01 Unified Dashboard',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    parser.add_argument('--full', action='store_true', help='Show all sections expanded')
    parser.add_argument('--temp', action='store_true', help='Show thermal/power info only')
    parser.add_argument('command', nargs='?', choices=['mig-status', 'util', 'container', 'users', 'allocations', 'monitor'], help='Subcommand')
    parser.add_argument('args', nargs='*', help='Additional arguments')

    args = parser.parse_args()

    # Initialize data layer
    data = DashboardData()
    view = DashboardView(data)

    # Handle commands
    if args.command == 'users':
        view.render_users_view()
    elif args.command == 'allocations':
        limit = int(args.args[0]) if args.args else 10
        view.render_allocations_view(limit)
    elif args.command == 'monitor':
        # Watch mode
        try:
            while True:
                os.system('clear')
                view.render_default_view()
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nMonitoring stopped.")
    else:
        # Default view
        view.render_default_view()


if __name__ == '__main__':
    main()
