#!/bin/bash
# DS01 Container Stop - Stops containers via mlc-stop with DS01 UX
# Tier 2 Command - Wraps AIME mlc-stop with interactive GUI and safety checks

set -e

# Script paths
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
INFRA_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"
MLC_STOP="$INFRA_ROOT/aime-ml-containers/mlc-stop"
RESOURCE_PARSER="$INFRA_ROOT/scripts/docker/get_resource_limits.py"
GPU_ALLOCATOR="$INFRA_ROOT/scripts/docker/gpu_allocator.py"

# Source interactive library
source /usr/local/lib/interactive-select.sh

BLUE='\033[94m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

USERNAME=$(whoami)
USER_ID=$(id -u)

# Helper function to get user's resource limits
get_user_lifecycle_limits() {
    local username="$1"
    if [ ! -f "$RESOURCE_PARSER" ]; then
        echo "None|None|None"
        return
    fi

    local idle_timeout=$(python3 "$RESOURCE_PARSER" "$username" --idle-timeout 2>/dev/null || echo "None")
    local max_runtime=$(python3 "$RESOURCE_PARSER" "$username" --max-runtime 2>/dev/null || echo "None")
    local gpu_hold=$(python3 "$RESOURCE_PARSER" "$username" --gpu-hold-time 2>/dev/null || echo "None")

    echo "${idle_timeout}|${max_runtime}|${gpu_hold}"
}

usage() {
    echo ""
    echo -e "${BOLD}DS01 Container Stop${NC}"
    echo ""
    echo -e "${CYAN}Usage:${NC}"
    echo "  container-stop [name] [options]"
    echo "  container-stop                   # Prompts to select running container (if none specified)"
    echo ""
    echo -e "${CYAN}Options:${NC}"
    echo "  --guided        Show detailed explanations for beginners"
    echo "  -f, --force     Force stop (kill immediately)"
    echo "  -t, --timeout   Timeout in seconds (default: 10)"
    echo "  -a, --all       Stop all your containers"
    echo "  -v, --verbose   Show detailed shutdown process (SIGTERM/SIGKILL timing)"
    echo "  -h, --help      Show this help message"
    echo ""
    echo -e "${CYAN}Description:${NC}"
    echo "  Gracefully stops a running container, allowing processes"
    echo "  to save state and clean up. The container can be restarted"
    echo -e "  later with ${GREEN}container-run${NC}."
    echo ""
    echo -e "${RED}‚ö† Important:${NC}"
    echo -e "  This ${BOLD}completely stops${NC} the container, including:"
    echo "  ‚Ä¢ All running processes"
    echo "  ‚Ä¢ Jupyter sessions"
    echo "  ‚Ä¢ Training jobs"
    echo "  ‚Ä¢ SSH connections"
    echo ""
    echo -e "${YELLOW}üí° Alternative:${NC}"
    echo -e "  To exit without stopping: Just type ${GREEN}exit${NC} (container keeps running)"
    echo -e "  Reconnect later with: ${GREEN}container-run <name>${NC}"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  container-stop my-project              # Graceful stop"
    echo "  container-stop training --force        # Force stop immediately"
    echo "  container-stop --all                   # Stop all your containers"
    echo ""
    echo -e "${CYAN}After stopping:${NC}"
    echo -e "  ‚Ä¢ Restart: ${GREEN}container-run <name>${NC}"
    echo -e "  ‚Ä¢ Remove:  ${GREEN}container-remove <name>${NC}"
    echo -e "  ‚Ä¢ Status:  ${GREEN}container-list${NC}"
    echo ""
}

stop_container() {
    local container_name="$1"
    local force="$2"
    local timeout="$3"
    local verbose="$4"

    local container_tag="${container_name}._.$USER_ID"

    # Check if container exists
    if ! docker ps -a --format "{{.Names}}" | grep -q "^${container_tag}$"; then
        echo -e "${RED}‚úó${NC} Container '$container_name' not found"
        return 1
    fi

    # Check if running
    if ! docker ps --format "{{.Names}}" | grep -q "^${container_tag}$"; then
        echo -e "${DIM}‚óã${NC} Container '$container_name' already stopped"
        return 0
    fi

    # Get container info (DS01 display)
    local uptime=$(docker ps --format "{{.Status}}" --filter "name=^${container_tag}$")
    local image=$(docker inspect --format "{{.Config.Image}}" "$container_tag" 2>/dev/null)

    echo -e "${BOLD}Container:${NC} ${CYAN}$container_name${NC}"
    echo -e "${BOLD}Uptime:${NC}    $uptime"
    echo -e "${BOLD}Image:${NC}     $image"
    echo ""

    # Warning about running processes (DS01-specific)
    local process_count=$(docker exec "$container_tag" ps aux 2>/dev/null | wc -l)
    if [ "$process_count" -gt 5 ]; then
        echo -e "${YELLOW}‚ö† Warning: Container has running processes${NC}"
        if [ "$GUIDED" = true ]; then
            echo -e "${CYAN}‚Ñπ ${NC}This means training jobs, Jupyter notebooks, or other programs are still running."
            echo -e "  They will be terminated when the container stops."
        fi
        echo ""
    fi

    # Check if mlc-stop exists
    if [ ! -f "$MLC_STOP" ]; then
        # Fallback to docker directly
        if [ "$force" = true ]; then
            echo -e "${YELLOW}Force stopping...${NC}"
            if docker kill "$container_tag" > /dev/null 2>&1; then
                echo -e "${GREEN}‚úì${NC} Container force stopped"
                return 0
            else
                echo -e "${RED}‚úó${NC} Failed to stop container"
                return 1
            fi
        else
            echo -e "${CYAN}Sending SIGTERM to container (${timeout}s graceful timeout)...${NC}"
            if [ "$verbose" = true ]; then
                echo -e "${DIM}  ‚Ä¢ SIGTERM sent, waiting for graceful shutdown...${NC}"
            fi

            # Track timing
            local start_time=$(date +%s%3N)  # milliseconds
            if docker stop -t "$timeout" "$container_tag" > /dev/null 2>&1; then
                local end_time=$(date +%s%3N)
                local elapsed_ms=$((end_time - start_time))
                local elapsed_s=$(echo "scale=2; $elapsed_ms / 1000" | bc)

                # Check if SIGKILL was needed (took longer than timeout)
                local timeout_ms=$((timeout * 1000))
                if [ "$elapsed_ms" -ge "$timeout_ms" ]; then
                    echo -e "${YELLOW}‚úì${NC} Container stopped (${elapsed_s}s - required SIGKILL)\n"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  ‚Ä¢ Process didn't respond to SIGTERM within ${timeout}s${NC}"
                        echo -e "${DIM}  ‚Ä¢ SIGKILL sent to force termination${NC}"
                    fi
                else
                    echo -e "${GREEN}‚úì${NC} Container stopped (${elapsed_s}s)"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  ‚Ä¢ Graceful shutdown successful${NC}\n"
                    fi
                fi
                return 0
            else
                echo -e "${RED}‚úó${NC} Failed to stop container"
                return 1
            fi
        fi
    fi

    # Stop container via mlc-stop (AIME Tier 1)
    if [ "$force" = true ]; then
        echo -e "${YELLOW}Force stopping...${NC}"
        if [ "$GUIDED" = true ]; then
            echo -e "${CYAN}‚Ñπ ${NC}Force stop sends SIGKILL, immediately terminating all processes without cleanup."
        fi
        # mlc-stop -f for force
        if bash "$MLC_STOP" "$container_name" -f -s > /dev/null 2>&1; then
            echo -e "${GREEN}‚úì${NC} Container force stopped"
            return 0
        else
            # Fallback to docker kill
            if docker kill "$container_tag" > /dev/null 2>&1; then
                echo -e "${GREEN}‚úì${NC} Container force stopped"
                return 0
            else
                echo -e "${RED}‚úó${NC} Failed to stop container"
                return 1
            fi
        fi
    else
        echo -e "${CYAN}Sending SIGTERM to container (${timeout}s graceful timeout)...${NC}"
        if [ "$GUIDED" = true ]; then
            echo -e "${CYAN}‚Ñπ ${NC}Graceful stop sends SIGTERM, allowing processes to save state and exit cleanly."
        fi
        if [ "$verbose" = true ]; then
            echo -e "${DIM}  ‚Ä¢ Using mlc-stop for graceful shutdown...${NC}"
        fi

        # Track timing
        local start_time=$(date +%s%3N)  # milliseconds

        # Call mlc-stop with script mode (-s for non-interactive)
        if bash "$MLC_STOP" "$container_name" -s > /dev/null 2>&1; then
            local end_time=$(date +%s%3N)
            local elapsed_ms=$((end_time - start_time))
            local elapsed_s=$(echo "scale=2; $elapsed_ms / 1000" | bc)

            # Check if SIGKILL was needed
            local timeout_ms=$((timeout * 1000))
            if [ "$elapsed_ms" -ge "$timeout_ms" ]; then
                echo -e "${YELLOW}‚úì${NC} Container stopped (${elapsed_s}s - required SIGKILL)\n"
                if [ "$verbose" = true ]; then
                    echo -e "${DIM}  ‚Ä¢ Process didn't respond to SIGTERM within ${timeout}s${NC}"
                    echo -e "${DIM}  ‚Ä¢ SIGKILL sent to force termination${NC}"
                fi
            else
                echo -e "${GREEN}‚úì${NC} Container stopped (${elapsed_s}s)\n"
                if [ "$verbose" = true ]; then
                    echo -e "${DIM}  ‚Ä¢ Graceful shutdown successfu${NC}\n"
                fi
            fi
            return 0
        else
            # Fallback to docker stop
            if [ "$verbose" = true ]; then
                echo -e "${DIM}  ‚Ä¢ mlc-stop failed, falling back to docker stop...${NC}"
            fi

            if docker stop -t "$timeout" "$container_tag" > /dev/null 2>&1; then
                local end_time=$(date +%s%3N)
                local elapsed_ms=$((end_time - start_time))
                local elapsed_s=$(echo "scale=2; $elapsed_ms / 1000" | bc)

                local timeout_ms=$((timeout * 1000))
                if [ "$elapsed_ms" -ge "$timeout_ms" ]; then
                    echo -e "${YELLOW}‚úì${NC} Container stopped (${elapsed_s}s - required SIGKILL)"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  ‚Ä¢ SIGKILL used after timeout${NC}"
                    fi
                else
                    echo -e "${GREEN}‚úì${NC} Container stopped (${elapsed_s}s)"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  ‚Ä¢ Graceful shutdown successful (via docker stop)${NC}"
                    fi
                fi
                return 0
            else
                echo -e "${RED}‚úó${NC} Failed to stop container"
                return 1
            fi
        fi
    fi
}

# Parse arguments
CONTAINER_NAME=""
GUIDED=false
FORCE=false
TIMEOUT=10
STOP_ALL=false
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --guided)
            GUIDED=true
            shift
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -t|--timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -a|--all)
            STOP_ALL=true
            shift
            ;;
        -h|--help|--info)
            usage
            exit 0
            ;;
        -*)
            echo -e "${RED}‚úó Unknown option: $1${NC}\n"
            usage
            exit 1
            ;;
        *)
            if [ -z "$CONTAINER_NAME" ]; then
                CONTAINER_NAME="$1"
            else
                echo -e "${RED}‚úó Too many arguments${NC}\n"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
echo -e "${CYAN}${BOLD}    Stopping Container${NC}"
echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}\n"

# Stop all containers
if [ "$STOP_ALL" = true ]; then
    CONTAINERS=$(docker ps --format "{{.Names}}" --filter "name=._.$USER_ID" | sed "s/\._\.$USER_ID//")

    if [ -z "$CONTAINERS" ]; then
        echo -e "${YELLOW}No running containers found${NC}\n"
        exit 0
    fi

    echo -e "${BOLD}Stopping all your containers:${NC}\n"

    SUCCESS_COUNT=0
    FAIL_COUNT=0

    while IFS= read -r name; do
        [ -z "$name" ] && continue
        if stop_container "$name" "$FORCE" "$TIMEOUT" "$VERBOSE"; then
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
            FAIL_COUNT=$((FAIL_COUNT + 1))
        fi
        echo ""
    done <<< "$CONTAINERS"

    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${BOLD}Summary:${NC}"
    echo -e "  Stopped: ${GREEN}$SUCCESS_COUNT${NC}"
    if [ "$FAIL_COUNT" -gt 0 ]; then
        echo -e "  Failed:  ${RED}$FAIL_COUNT${NC}"
    fi
    echo ""
    exit 0
fi

# Show guided explanation BEFORE selection
if [ "$GUIDED" = true ] && [ -z "$CONTAINER_NAME" ] && [ "$STOP_ALL" = false ]; then
    # Get user's actual limits
    IFS='|' read -r idle_timeout max_runtime gpu_hold <<< "$(get_user_lifecycle_limits "$USERNAME")"

    echo -e "${CYAN}‚Ñπ ${NC}${BOLD}What does stopping mean?${NC}"
    echo -e "  Stopping a container halts all processes inside it, but preserves:"
    echo -e "  ‚Ä¢ All your files and data in the workspace"
    echo -e "  ‚Ä¢ The container configuration"
    echo -e "  ‚Ä¢ Any changes you made inside the container"
    echo -e "  You can restart it later with ${GREEN}container-run${NC} and continue where you left off."
    echo ""
    echo -e "${CYAN}‚Ñπ ${NC}${BOLD}GPU allocation after stop:${NC}"
    if [ "$gpu_hold" != "None" ] && [ "$gpu_hold" != "null" ] && [ "$gpu_hold" != "indefinite" ]; then
        echo -e "  ‚Ä¢ Your GPU is held for ${CYAN}$gpu_hold${NC} after stopping"
        echo -e "  ‚Ä¢ Restart within ${CYAN}$gpu_hold${NC} ‚Üí GPU still yours (no re-competing)"
        echo -e "  ‚Ä¢ After ${CYAN}$gpu_hold${NC} ‚Üí GPU auto-released for others"
    elif [ "$gpu_hold" = "indefinite" ]; then
        echo -e "  ‚Ä¢ GPU held ${CYAN}indefinitely${NC} until you run container-remove"
    fi
    echo -e "  ‚Ä¢ Need GPU freed immediately? Use ${GREEN}container-remove${NC}"
    echo ""
    echo -e "${CYAN}‚Ñπ ${NC}${BOLD}Your resource limits:${NC}"
    if [ "$idle_timeout" != "None" ] && [ "$idle_timeout" != "null" ]; then
        echo -e "  ‚Ä¢ Auto-stop after ${CYAN}$idle_timeout${NC} of GPU inactivity"
    else
        echo -e "  ‚Ä¢ No auto-stop on idle"
    fi
    if [ "$max_runtime" != "None" ] && [ "$max_runtime" != "null" ]; then
        echo -e "  ‚Ä¢ Max container lifetime: ${CYAN}$max_runtime${NC}"
    fi
    echo ""
    echo -e "${CYAN}‚Ñπ ${NC}${BOLD}Behind the scenes:${NC}"
    echo -e "  ‚Ä¢ This ensures consistent container lifecycle management"
    echo -e "  ‚Ä¢ DS01 adds safety checks and user confirmations"
    echo ""
fi

# If no container name provided, prompt to select running containers (DS01 UX)
if [ -z "$CONTAINER_NAME" ] && [ "$STOP_ALL" = false ]; then
    CONTAINER_NAME=$(select_container "running")
    if [ -z "$CONTAINER_NAME" ]; then
        echo "No selection made. Exiting."
        exit 0
    fi
    echo ""
fi

# Validate container name
if [ -z "$CONTAINER_NAME" ] && [ "$STOP_ALL" = false ]; then
    echo -e "${RED}‚úó Container name is required${NC}\n"
    usage
    exit 1
fi

# Warning message (DS01 safety check)
echo -e "${RED}‚ö† This will STOP the container${NC}\n"
echo -e "${BOLD}All processes will be terminated, including:${NC}"
echo -e "  ‚Ä¢ Training jobs"
echo -e "  ‚Ä¢ Jupyter sessions"
echo -e "  ‚Ä¢ SSH connections"
echo ""

read -p "Continue? [y/N]: " CONFIRM
if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
    echo "Cancelled."
    exit 0
fi
echo ""

# Stop container
if stop_container "$CONTAINER_NAME" "$FORCE" "$TIMEOUT" "$VERBOSE"; then

    # Mark container as stopped (starts GPU hold timer)
    CONTAINER_TAG="${CONTAINER_NAME}._.${USER_ID}"
    if [ -f "$GPU_ALLOCATOR" ]; then
        python3 "$GPU_ALLOCATOR" mark-stopped "$CONTAINER_TAG" >/dev/null 2>&1 || true
    fi

    # Get container hold time (needed for messages below)
    CONTAINER_HOLD=$(python3 "$RESOURCE_PARSER" "$USERNAME" --container-hold-time 2>/dev/null || echo "12h")

    # Check if container has GPU allocated and show warning
    if [ -f "$GPU_ALLOCATOR" ]; then
        GPU_INFO=$(python3 "$GPU_ALLOCATOR" user-status "$USERNAME" 2>/dev/null | grep "$CONTAINER_TAG" || true)

        if [ -n "$GPU_INFO" ]; then
            # Get user's lifecycle limits
            IFS='|' read -r idle_timeout max_runtime gpu_hold <<< "$(get_user_lifecycle_limits "$USERNAME")"

            echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
            echo -e "${YELLOW}${BOLD}    ‚ö† GPU Still Allocated${NC}"
            echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}\n"

            if [ "$GUIDED" = true ]; then
                echo -e "${BOLD}Your container still has a GPU allocated!${NC}"
                echo ""

                if [ "$gpu_hold" = "indefinite" ] || [ "$gpu_hold" = "null" ] || [ "$gpu_hold" = "None" ]; then
                    echo -e "${BOLD}GPU will be held ${CYAN}indefinitely${NC} (until you cleanup)"
                else
                    echo -e "${BOLD}GPU will be held for ${CYAN}$gpu_hold${NC}"
                    echo -e "  ‚Ä¢ After that, GPU will be auto-released"
                fi
                echo -e "  ‚Ä¢ Other users cannot use this GPU during this time"
                echo ""

                echo -e "${BOLD}Container will be held for ${CYAN}$CONTAINER_HOLD${NC}"
                echo -e "  ‚Ä¢ After that, container will be auto-removed"
                echo -e "  ‚Ä¢ ${YELLOW}Treat containers as ephemeral compute envs${NC}"
                echo ""
                echo -e "  This removes the container and ${BOLD}immediately frees the GPU${NC} for others."
                echo ""
                echo -e "${CYAN}‚Ñπ ${NC}${DIM}Your workspace files are always safe - cleanup only removes the container.${NC}"
                echo ""
                echo -e "  ${GREEN}What's preserved:${NC}"
                echo -e "    ‚Ä¢ Workspace files  ${DIM}(~/workspace/$CONTAINER_NAME/)${NC}"
                echo -e "    ‚Ä¢ Dockerfile       ${DIM}(~/dockerfiles/)${NC}"
                echo -e "    ‚Ä¢ Project configs"
                echo ""
                echo -e "  ${YELLOW}What's removed:${NC}"
                echo -e "    ‚Ä¢ Container instance  ${DIM}(recreate anytime with: container-create $CONTAINER_NAME)${NC}"
                echo -e "    ‚Ä¢ GPU allocation      ${DIM}(freed immediately)${NC}"
                echo ""
            fi
        fi
    fi

    # When called from retire orchestrator, automatically proceed with removal
    if [ "$DS01_ORCHESTRATOR" = "retire" ]; then
        # Skip prompt and proceed directly to removal (orchestrator handles messaging)
        "$SCRIPT_DIR/container-remove" "$CONTAINER_NAME" --force >/dev/null 2>&1
    else
        # Normal interactive flow: prompt user
        echo -e "${BOLD}Be a good citizen:${NC} if you're done with this container, release the GPU now: ${GREEN}container-remove $CONTAINER_NAME${NC}"

        if [ "$CONTAINER_HOLD" != "never" ] && [ "$CONTAINER_HOLD" != "None" ]; then
            echo -e "${CYAN}‚Ñπ${NC} ${DIM}If not removed, container will auto-remove after ${CONTAINER_HOLD}.${NC}"
            echo ""
        fi

        read -p "Remove container now? [Y/n] (default: yes): " REMOVE_NOW
        echo ""

        if [[ "$REMOVE_NOW" =~ ^[Nn]$ ]]; then
            echo -e "${GREEN}Container kept.${NC} Restart with: ${GREEN}container-run $CONTAINER_NAME${NC}"
            if [ "$gpu_hold" != "indefinite" ] && [ "$gpu_hold" != "null" ] && [ "$gpu_hold" != "None" ]; then
                echo -e "${DIM}Note: GPU held for $gpu_hold, then released${NC}"
            fi
            echo ""
        else
            echo -e "${CYAN}Removing container...${NC}"
            echo ""
            # Call container-remove with --force flag (skip confirmations since user already confirmed)
            if "$SCRIPT_DIR/container-remove" "$CONTAINER_NAME" --force; then
                echo ""
                echo -e "${GREEN}‚úì${NC} Container removed. GPU freed immediately."
                echo -e "${GREEN}‚úì${NC} Your workspace files are safe in: ${DIM}~/workspace/$CONTAINER_NAME/${NC}\n"
                echo -e "To resume, you can recreate the container anytime from the image/dockerfile"
                echo ""
            else
                echo -e "${YELLOW}‚ö†${NC} Container removal failed. You can remove it manually later:"
                echo -e "  ${GREEN}container-remove $CONTAINER_NAME${NC}"
                echo ""
            fi
        fi
    fi
else
    echo ""
    echo -e "${RED}Failed to stop container${NC}\n"
    echo -e "${BOLD}Try:${NC}"
    echo -e "  ‚Ä¢ Force stop: ${YELLOW}container-stop $CONTAINER_NAME --force${NC}"
    echo -e "  ‚Ä¢ Check logs: ${BLUE}docker logs ${CONTAINER_NAME}._.$USER_ID${NC}"
    echo ""
    exit 1
fi
