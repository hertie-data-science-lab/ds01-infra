#!/bin/bash
# DS01 Container Stop - L2 Atomic Command
# Stops containers via mlc-stop with DS01 UX
# Can be used standalone or called by orchestrators

set -e

# Script paths
SCRIPT_DIR="/opt/ds01-infra/scripts/user"
INFRA_ROOT="/opt/ds01-infra"
MLC_STOP="$INFRA_ROOT/aime-ml-containers/mlc-stop"
RESOURCE_PARSER="$INFRA_ROOT/scripts/docker/get_resource_limits.py"
GPU_ALLOCATOR="$INFRA_ROOT/scripts/docker/gpu-allocator-smart.py"

# Source DS01 context library for conditional output
if [[ -f "/opt/ds01-infra/scripts/lib/ds01-context.sh" ]]; then
    source /opt/ds01-infra/scripts/lib/ds01-context.sh
fi

# Source interactive library (with fallback for development)
if [ -f "/usr/local/lib/interactive-select.sh" ]; then
    source /usr/local/lib/interactive-select.sh
elif [ -f "$INFRA_ROOT/scripts/lib/interactive-select.sh" ]; then
    source "$INFRA_ROOT/scripts/lib/interactive-select.sh"
else
    echo "Error: interactive-select.sh not found"
    exit 1
fi

BLUE='\033[94m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

USERNAME=$(whoami)
USER_ID=$(id -u)

# Helper function to get user's resource limits
get_user_lifecycle_limits() {
    local username="$1"
    if [ ! -f "$RESOURCE_PARSER" ]; then
        echo "None|None|None"
        return
    fi

    local idle_timeout=$(python3 "$RESOURCE_PARSER" "$username" --idle-timeout 2>/dev/null || echo "None")
    local max_runtime=$(python3 "$RESOURCE_PARSER" "$username" --max-runtime 2>/dev/null || echo "None")
    local gpu_hold=$(python3 "$RESOURCE_PARSER" "$username" --gpu-hold-time 2>/dev/null || echo "None")

    echo "${idle_timeout}|${max_runtime}|${gpu_hold}"
}

usage() {
    echo ""
    echo -e "${BOLD}DS01 Container Stop${NC}"
    echo ""
    echo -e "${CYAN}Usage:${NC}"
    echo "  container-stop [name] [options]"
    echo "  container-stop                   # Prompts to select running container (if none specified)"
    echo ""
    echo -e "${CYAN}Options:${NC}"
    echo "  --guided           Show detailed explanations for beginners"
    echo "  -f, --force        Force stop (kill immediately)"
    echo "  -t, --timeout      Timeout in seconds (default: 10)"
    echo "  -a, --all          Stop all your containers"
    echo "  -v, --verbose      Show detailed shutdown process (SIGTERM/SIGKILL timing)"
    echo "  --keep-container   Don't prompt to remove container (opt-out of ephemeral model)"
    echo "  -h, --help         Show this help message"
    echo ""
    echo -e "${CYAN}Description:${NC}"
    echo "  Gracefully stops a running container, allowing processes"
    echo "  to save state and clean up. The container can be restarted"
    echo -e "  later with ${GREEN}container-run${NC}."
    echo ""
    echo -e "${RED}âš  Important:${NC}"
    echo -e "  This ${BOLD}completely stops${NC} the container, including:"
    echo "  â€¢ All running processes"
    echo "  â€¢ Jupyter sessions"
    echo "  â€¢ Training jobs"
    echo "  â€¢ SSH connections"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ Alternative:${NC}"
    echo -e "  To exit without stopping: Just type ${GREEN}exit${NC} (container keeps running)"
    echo -e "  Reconnect later with: ${GREEN}container-run <name>${NC}"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  container-stop my-project              # Graceful stop"
    echo "  container-stop training --force        # Force stop immediately"
    echo "  container-stop --all                   # Stop all your containers"
    echo ""
    echo -e "${CYAN}After stopping:${NC}"
    echo -e "  â€¢ Restart: ${GREEN}container-run <name>${NC}"
    echo -e "  â€¢ Remove:  ${GREEN}container-remove <name>${NC}"
    echo -e "  â€¢ Status:  ${GREEN}container-list${NC}"
    echo ""
}

stop_container() {
    local container_name="$1"
    local force="$2"
    local timeout="$3"
    local verbose="$4"

    local container_tag="${container_name}._.$USER_ID"

    # Check if container exists
    if ! docker ps -a --format "{{.Names}}" | grep -q "^${container_tag}$"; then
        echo -e "${RED}âœ—${NC} Container '$container_name' not found"
        return 1
    fi

    # Check if running
    if ! docker ps --format "{{.Names}}" | grep -q "^${container_tag}$"; then
        echo -e "${DIM}â—‹${NC} Container '$container_name' already stopped"
        return 0
    fi

    # Get container info (DS01 display)
    local uptime=$(docker ps --format "{{.Status}}" --filter "name=^${container_tag}$")
    local image=$(docker inspect --format "{{.Config.Image}}" "$container_tag" 2>/dev/null)

    echo -e "${BOLD}Container:${NC} ${CYAN}$container_name${NC}"
    echo -e "${BOLD}Uptime:${NC}    $uptime"
    echo -e "${BOLD}Image:${NC}     $image"
    echo ""

    # Warning about running processes (DS01-specific)
    local process_count=$(docker exec "$container_tag" ps aux 2>/dev/null | wc -l)
    if [ "$process_count" -gt 5 ]; then
        echo -e "${YELLOW}âš  Warning: Container has running processes${NC}"
        if [ "$GUIDED" = true ]; then
            echo -e "${CYAN}â„¹ ${NC}This means training jobs, Jupyter notebooks, or other programs are still running."
            echo -e "  They will be terminated when the container stops."
        fi
        echo ""
    fi

    # Check if mlc-stop exists
    if [ ! -f "$MLC_STOP" ]; then
        # Fallback to docker directly
        if [ "$force" = true ]; then
            echo -e "${YELLOW}Force stopping...${NC}"
            if docker kill "$container_tag" > /dev/null 2>&1; then
                echo -e "${GREEN}âœ“${NC} Container force stopped"
                return 0
            else
                echo -e "${RED}âœ—${NC} Failed to stop container"
                return 1
            fi
        else
            echo -e "${CYAN}Sending SIGTERM to container (${timeout}s graceful timeout)...${NC}"
            if [ "$verbose" = true ]; then
                echo -e "${DIM}  â€¢ SIGTERM sent, waiting for graceful shutdown...${NC}"
            fi

            # Track timing
            local start_time=$(date +%s%3N)  # milliseconds
            if docker stop -t "$timeout" "$container_tag" > /dev/null 2>&1; then
                local end_time=$(date +%s%3N)
                local elapsed_ms=$((end_time - start_time))
                local elapsed_s=$(echo "scale=2; $elapsed_ms / 1000" | bc)

                # Check if SIGKILL was needed (took longer than timeout)
                local timeout_ms=$((timeout * 1000))
                if [ "$elapsed_ms" -ge "$timeout_ms" ]; then
                    echo -e "${YELLOW}âœ“${NC} Container stopped (${elapsed_s}s - required SIGKILL)\n"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  â€¢ Process didn't respond to SIGTERM within ${timeout}s${NC}"
                        echo -e "${DIM}  â€¢ SIGKILL sent to force termination${NC}"
                    fi
                else
                    echo -e "${GREEN}âœ“${NC} Container stopped (${elapsed_s}s)"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  â€¢ Graceful shutdown successful${NC}\n"
                    fi
                fi
                return 0
            else
                echo -e "${RED}âœ—${NC} Failed to stop container"
                return 1
            fi
        fi
    fi

    # Stop container via mlc-stop (AIME Tier 1)
    if [ "$force" = true ]; then
        echo -e "${YELLOW}Force stopping...${NC}"
        if [ "$GUIDED" = true ]; then
            echo -e "${CYAN}â„¹ ${NC}Force stop sends SIGKILL, immediately terminating all processes without cleanup."
        fi
        # mlc-stop -f for force
        if bash "$MLC_STOP" "$container_name" -f -s > /dev/null 2>&1; then
            echo -e "${GREEN}âœ“${NC} Container force stopped"
            return 0
        else
            # Fallback to docker kill
            if docker kill "$container_tag" > /dev/null 2>&1; then
                echo -e "${GREEN}âœ“${NC} Container force stopped"
                return 0
            else
                echo -e "${RED}âœ—${NC} Failed to stop container"
                return 1
            fi
        fi
    else
        echo -e "${CYAN}Sending SIGTERM to container (${timeout}s graceful timeout)...${NC}"
        if [ "$GUIDED" = true ]; then
            echo -e "${CYAN}â„¹ ${NC}Graceful stop sends SIGTERM, allowing processes to save state and exit cleanly."
        fi
        if [ "$verbose" = true ]; then
            echo -e "${DIM}  â€¢ Using mlc-stop for graceful shutdown...${NC}"
        fi

        # Track timing
        local start_time=$(date +%s%3N)  # milliseconds

        # Call mlc-stop with script mode (-s for non-interactive)
        if bash "$MLC_STOP" "$container_name" -s > /dev/null 2>&1; then
            local end_time=$(date +%s%3N)
            local elapsed_ms=$((end_time - start_time))
            local elapsed_s=$(echo "scale=2; $elapsed_ms / 1000" | bc)

            # Check if SIGKILL was needed
            local timeout_ms=$((timeout * 1000))
            if [ "$elapsed_ms" -ge "$timeout_ms" ]; then
                echo -e "${YELLOW}âœ“${NC} Container stopped (${elapsed_s}s - required SIGKILL)\n"
                if [ "$verbose" = true ]; then
                    echo -e "${DIM}  â€¢ Process didn't respond to SIGTERM within ${timeout}s${NC}"
                    echo -e "${DIM}  â€¢ SIGKILL sent to force termination${NC}"
                fi
            else
                echo -e "${GREEN}âœ“${NC} Container stopped (${elapsed_s}s)\n"
                if [ "$verbose" = true ]; then
                    echo -e "${DIM}  â€¢ Graceful shutdown successfu${NC}\n"
                fi
            fi
            return 0
        else
            # Fallback to docker stop
            if [ "$verbose" = true ]; then
                echo -e "${DIM}  â€¢ mlc-stop failed, falling back to docker stop...${NC}"
            fi

            if docker stop -t "$timeout" "$container_tag" > /dev/null 2>&1; then
                local end_time=$(date +%s%3N)
                local elapsed_ms=$((end_time - start_time))
                local elapsed_s=$(echo "scale=2; $elapsed_ms / 1000" | bc)

                local timeout_ms=$((timeout * 1000))
                if [ "$elapsed_ms" -ge "$timeout_ms" ]; then
                    echo -e "${YELLOW}âœ“${NC} Container stopped (${elapsed_s}s - required SIGKILL)"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  â€¢ SIGKILL used after timeout${NC}"
                    fi
                else
                    echo -e "${GREEN}âœ“${NC} Container stopped (${elapsed_s}s)"
                    if [ "$verbose" = true ]; then
                        echo -e "${DIM}  â€¢ Graceful shutdown successful (via docker stop)${NC}"
                    fi
                fi
                return 0
            else
                echo -e "${RED}âœ—${NC} Failed to stop container"
                return 1
            fi
        fi
    fi
}

# Parse arguments
CONTAINER_NAME=""
GUIDED=false
FORCE=false
TIMEOUT=10
STOP_ALL=false
VERBOSE=false
KEEP_CONTAINER=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --guided)
            GUIDED=true
            shift
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -t|--timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -a|--all)
            STOP_ALL=true
            shift
            ;;
        --keep-container)
            KEEP_CONTAINER=true
            shift
            ;;
        -h|--help|--info)
            usage
            exit 0
            ;;
        -*)
            echo -e "${RED}âœ— Unknown option: $1${NC}\n"
            usage
            exit 1
            ;;
        *)
            if [ -z "$CONTAINER_NAME" ]; then
                CONTAINER_NAME="$1"
            else
                echo -e "${RED}âœ— Too many arguments${NC}\n"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${CYAN}${BOLD}    Stopping Container${NC}"
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"

# Stop all containers
if [ "$STOP_ALL" = true ]; then
    CONTAINERS=$(docker ps --format "{{.Names}}" --filter "name=._.$USER_ID" | sed "s/\._\.$USER_ID//")

    if [ -z "$CONTAINERS" ]; then
        echo -e "${YELLOW}No running containers found${NC}\n"
        exit 0
    fi

    echo -e "${BOLD}Stopping all your containers:${NC}\n"

    SUCCESS_COUNT=0
    FAIL_COUNT=0

    while IFS= read -r name; do
        [ -z "$name" ] && continue
        if stop_container "$name" "$FORCE" "$TIMEOUT" "$VERBOSE"; then
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
            FAIL_COUNT=$((FAIL_COUNT + 1))
        fi
        echo ""
    done <<< "$CONTAINERS"

    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Summary:${NC}"
    echo -e "  Stopped: ${GREEN}$SUCCESS_COUNT${NC}"
    if [ "$FAIL_COUNT" -gt 0 ]; then
        echo -e "  Failed:  ${RED}$FAIL_COUNT${NC}"
    fi
    echo ""
    exit 0
fi

# Show guided explanation BEFORE selection
if [ "$GUIDED" = true ] && [ -z "$CONTAINER_NAME" ] && [ "$STOP_ALL" = false ]; then
    # Get user's actual limits
    IFS='|' read -r idle_timeout max_runtime gpu_hold <<< "$(get_user_lifecycle_limits "$USERNAME")"

    echo -e "${CYAN}â„¹ ${NC}${BOLD}What does stopping mean?${NC}"
    echo -e "  Stopping a container halts all processes inside it, but preserves:"
    echo -e "  â€¢ All your files and data in the workspace"
    echo -e "  â€¢ The container configuration"
    echo -e "  â€¢ Any changes you made inside the container"
    echo -e "  You can restart it later with ${GREEN}container-run${NC} and continue where you left off."
    echo ""
    echo -e "${CYAN}â„¹ ${NC}${BOLD}GPU allocation after stop:${NC}"
    if [ "$gpu_hold" != "None" ] && [ "$gpu_hold" != "null" ] && [ "$gpu_hold" != "indefinite" ]; then
        echo -e "  â€¢ Your GPU is held for ${CYAN}$gpu_hold${NC} after stopping"
        echo -e "  â€¢ Restart within ${CYAN}$gpu_hold${NC} â†’ GPU still yours (no re-competing)"
        echo -e "  â€¢ After ${CYAN}$gpu_hold${NC} â†’ GPU auto-released for others"
    elif [ "$gpu_hold" = "indefinite" ]; then
        echo -e "  â€¢ GPU held ${CYAN}indefinitely${NC} until you run container-remove"
    fi
    echo -e "  â€¢ Need GPU freed immediately? Use ${GREEN}container-remove${NC}"
    echo ""
    echo -e "${CYAN}â„¹ ${NC}${BOLD}Your resource limits:${NC}"
    if [ "$idle_timeout" != "None" ] && [ "$idle_timeout" != "null" ]; then
        echo -e "  â€¢ Auto-stop after ${CYAN}$idle_timeout${NC} of GPU inactivity"
    else
        echo -e "  â€¢ No auto-stop on idle"
    fi
    if [ "$max_runtime" != "None" ] && [ "$max_runtime" != "null" ]; then
        echo -e "  â€¢ Max container lifetime: ${CYAN}$max_runtime${NC}"
    fi
    echo ""
    echo -e "${CYAN}â„¹ ${NC}${BOLD}Behind the scenes:${NC}"
    echo -e "  â€¢ This ensures consistent container lifecycle management"
    echo -e "  â€¢ DS01 adds safety checks and user confirmations"
    echo ""
fi

# If no container name provided, prompt to select running containers (DS01 UX)
if [ -z "$CONTAINER_NAME" ] && [ "$STOP_ALL" = false ]; then
    CONTAINER_NAME=$(select_container "running")
    if [ -z "$CONTAINER_NAME" ]; then
        echo "No selection made. Exiting."
        exit 0
    fi
    echo ""
fi

# Validate container name
if [ -z "$CONTAINER_NAME" ] && [ "$STOP_ALL" = false ]; then
    echo -e "${RED}âœ— Container name is required${NC}\n"
    usage
    exit 1
fi

# Warning message (DS01 safety check) - skip if --force
if [ "$FORCE" != "true" ]; then
    echo -e "${RED}âš  This will STOP the container${NC}\n"
    echo -e "${BOLD}All processes will be terminated, including:${NC}"
    echo -e "  â€¢ Training jobs"
    echo -e "  â€¢ Jupyter sessions"
    echo -e "  â€¢ SSH connections"
    echo ""

    read -p "Continue? [y/N]: " CONFIRM
    if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi
    echo ""
fi

# Stop container
if stop_container "$CONTAINER_NAME" "$FORCE" "$TIMEOUT" "$VERBOSE"; then

    # GPU hold timer starts automatically (Docker tracks FinishedAt timestamp)

    # Get container hold time (needed for messages below)
    CONTAINER_HOLD=$(python3 "$RESOURCE_PARSER" "$USERNAME" --container-hold-time 2>/dev/null || echo "12h")

    # Check if container has GPU allocated and show warning
    if [ -f "$GPU_ALLOCATOR" ]; then
        GPU_INFO=$(python3 "$GPU_ALLOCATOR" user-status "$USERNAME" 2>/dev/null | grep "$CONTAINER_TAG" || true)

        if [ -n "$GPU_INFO" ]; then
            # Get user's lifecycle limits
            IFS='|' read -r idle_timeout max_runtime gpu_hold <<< "$(get_user_lifecycle_limits "$USERNAME")"

            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
            echo -e "${YELLOW}${BOLD}    âš  GPU Still Allocated${NC}"
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"

            if [ "$GUIDED" = true ]; then
                echo -e "${BOLD}Your container still has a GPU allocated!${NC}"
                echo ""

                if [ "$gpu_hold" = "indefinite" ] || [ "$gpu_hold" = "null" ] || [ "$gpu_hold" = "None" ]; then
                    echo -e "${BOLD}GPU will be held ${CYAN}indefinitely${NC} (until you cleanup)"
                else
                    echo -e "${BOLD}GPU will be held for ${CYAN}$gpu_hold${NC}"
                    echo -e "  â€¢ After that, GPU will be auto-released"
                fi
                echo -e "  â€¢ Other users cannot use this GPU during this time"
                echo ""

                echo -e "${BOLD}Container will be held for ${CYAN}$CONTAINER_HOLD${NC}"
                echo -e "  â€¢ After that, container will be auto-removed"
                echo -e "  â€¢ ${YELLOW}Treat containers as ephemeral compute envs${NC}"
                echo ""
                echo -e "  This removes the container and ${BOLD}immediately frees the GPU${NC} for others."
                echo ""
                echo -e "${CYAN}â„¹ ${NC}${DIM}Your workspace files are always safe - cleanup only removes the container.${NC}"
                echo ""
                echo -e "  ${GREEN}What's preserved:${NC}"
                echo -e "    â€¢ Workspace files  ${DIM}(~/workspace/$CONTAINER_NAME/)${NC}"
                echo -e "    â€¢ Dockerfile       ${DIM}(~/dockerfiles/)${NC}"
                echo -e "    â€¢ Project configs"
                echo ""
                echo -e "  ${YELLOW}What's removed:${NC}"
                echo -e "    â€¢ Container instance  ${DIM}(recreate anytime with: container-create $CONTAINER_NAME)${NC}"
                echo -e "    â€¢ GPU allocation      ${DIM}(freed immediately)${NC}"
                echo ""
            fi
        fi
    fi

    # When called from retire orchestrator, auto-remove silently
    if [ "$DS01_ORCHESTRATOR" = "retire" ]; then
        # Silently remove container (orchestrator handles all messaging)
        "$SCRIPT_DIR/container-remove" "$CONTAINER_NAME" --force >/dev/null 2>&1
    # Show next steps (no removal prompt - separation of concerns)
    elif [ "$KEEP_CONTAINER" = false ]; then
        # Ephemeral model: inform about retirement option
        echo ""
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${YELLOW}${BOLD}    Next Steps${NC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo -e "${BOLD}Container stopped successfully.${NC}"
        echo ""
        echo -e "${BOLD}To resume:${NC}"
        echo -e "  ${GREEN}container-run $CONTAINER_NAME${NC}"
        echo ""
        echo -e "${BOLD}To free GPU immediately:${NC}"
        echo -e "  ${GREEN}container-retire $CONTAINER_NAME${NC}  ${DIM}(stops + removes container)${NC}"
        echo ""

        if [ "$gpu_hold" != "indefinite" ] && [ "$gpu_hold" != "null" ] && [ "$gpu_hold" != "None" ]; then
            echo -e "${CYAN}â„¹${NC} ${DIM}GPU will be held for ${CYAN}$gpu_hold${NC}${DIM}, then auto-released${NC}"
        fi

        if [ "$CONTAINER_HOLD" != "never" ] && [ "$CONTAINER_HOLD" != "None" ]; then
            echo -e "${CYAN}â„¹${NC} ${DIM}Container will auto-remove after ${CYAN}$CONTAINER_HOLD${NC}${DIM} if not restarted${NC}"
        fi
        echo ""
    else
        # --keep-container flag: skip removal prompt
        echo ""
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${YELLOW}${BOLD}    Container Kept (--keep-container)${NC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo -e "${BOLD}Container stopped but not removed.${NC}"
        echo ""
        echo -e "${BOLD}To restart:${NC}"
        echo -e "  ${GREEN}container-run $CONTAINER_NAME${NC}"
        echo ""
        if [ "$gpu_hold" != "indefinite" ] && [ "$gpu_hold" != "null" ] && [ "$gpu_hold" != "None" ]; then
            echo -e "${YELLOW}âš  GPU Note:${NC}"
            echo -e "  GPU will be held for ${CYAN}$gpu_hold${NC}, then auto-released"
            echo ""
        fi
        if [ "$CONTAINER_HOLD" != "never" ] && [ "$CONTAINER_HOLD" != "None" ]; then
            echo -e "${YELLOW}âš  Container Lifecycle:${NC}"
            echo -e "  Container will auto-remove after ${CYAN}$CONTAINER_HOLD${NC} if not restarted"
            echo ""
        fi
        echo -e "${DIM}Tip: For immediate GPU release, use: ${GREEN}container-retire $CONTAINER_NAME${NC}"
        echo ""
    fi
else
    echo ""
    echo -e "${RED}Failed to stop container${NC}\n"
    echo -e "${BOLD}Try:${NC}"
    echo -e "  â€¢ Force stop: ${YELLOW}container-stop $CONTAINER_NAME --force${NC}"
    echo -e "  â€¢ Check logs: ${BLUE}docker logs ${CONTAINER_NAME}._.$USER_ID${NC}"
    echo ""
    exit 1
fi
