#!/bin/bash
# Docker Image Updater with Interactive Package Management
# Supports adding/removing packages without manual Dockerfile editing

set -e

# Source DS01 context library for conditional output
[[ -f "/opt/ds01-infra/scripts/lib/ds01-context.sh" ]] && \
    source /opt/ds01-infra/scripts/lib/ds01-context.sh

BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

USERNAME=$(whoami)
DOCKERFILES_DIR="$HOME/dockerfiles"

normalize_package_name() {
    # Normalize package name: lowercase, strip version specifiers
    local pkg="$1"
    # Remove version specifiers (==, >=, <=, ~=, etc.)
    pkg=$(echo "$pkg" | sed 's/[=<>~!].*//')
    # Convert to lowercase
    echo "$pkg" | tr '[:upper:]' '[:lower:]'
}

check_duplicate_packages() {
    # Check if any input packages are already in existing packages
    # Args: $1 = new packages (space-separated), $2... = existing package lists
    local new_packages="$1"
    shift
    local existing_packages="$*"

    # Build array of existing packages (normalized)
    local existing_array=()
    for pkg in $existing_packages; do
        local normalized=$(normalize_package_name "$pkg")
        existing_array+=("$normalized")
    done

    # Check each new package
    local duplicates=()
    for new_pkg in $new_packages; do
        local new_normalized=$(normalize_package_name "$new_pkg")
        for existing in "${existing_array[@]}"; do
            if [ "$new_normalized" = "$existing" ]; then
                duplicates+=("$new_pkg")
                break
            fi
        done
    done

    # Return duplicates (space-separated)
    if [ ${#duplicates[@]} -gt 0 ]; then
        echo "${duplicates[@]}"
        return 1
    fi
    return 0
}

# ============================================================================
# Requirements.txt Import Functions
# ============================================================================

scan_requirements_files() {
    # Scans ~/workspace/*/ and ~/ for requirements.txt files
    # Outputs: "path|display_name" for each entry, one per line

    local workspace_dir="$HOME/workspace"

    # Scan ~/workspace/*/requirements.txt (direct children only)
    if [ -d "$workspace_dir" ]; then
        for project_dir in "$workspace_dir"/*/; do
            if [ -d "$project_dir" ]; then
                local req_file="${project_dir}requirements.txt"
                if [ -f "$req_file" ] && [ -r "$req_file" ]; then
                    local project_name=$(basename "$project_dir")
                    echo "$req_file|$project_name"
                fi
            fi
        done
    fi

    # Check ~/requirements.txt (global)
    local global_req="$HOME/requirements.txt"
    if [ -f "$global_req" ] && [ -r "$global_req" ]; then
        echo "$global_req|Global (home directory)"
    fi
}

validate_requirements_file() {
    # Validates requirements.txt file
    # Args: $1 = file path
    # Returns: 0 on success, 1 on failure

    local req_file="$1"

    if [ ! -f "$req_file" ]; then
        echo -e "${RED}Error: File not found: $req_file${NC}" >&2
        return 1
    fi

    if [ ! -r "$req_file" ]; then
        echo -e "${RED}Error: Cannot read file: $req_file${NC}" >&2
        return 1
    fi

    # Check file is not empty (excluding comments and blank lines)
    local line_count
    line_count=$(grep -v '^#' "$req_file" | grep -v '^[[:space:]]*$' | wc -l)
    if [ "$line_count" -eq 0 ]; then
        echo -e "${YELLOW}Warning: requirements.txt appears to be empty${NC}" >&2
    fi

    return 0
}

read_requirements_packages() {
    # Reads packages from requirements.txt file
    # Args: $1 = file path
    # Outputs: space-separated package list

    local req_file="$1"
    local packages=""

    while IFS= read -r line; do
        # Skip comments
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        # Skip empty lines
        [[ -z "${line// }" ]] && continue
        # Skip -r/-e/--requirement/--editable
        [[ "$line" =~ ^[[:space:]]*- ]] && continue

        # Trim whitespace and normalize version specifiers
        local pkg
        pkg=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | \
              sed 's/[[:space:]]*\([><=!~]\+\)[[:space:]]*/\1/g')

        if [ -n "$pkg" ]; then
            packages="$packages $pkg"
        fi
    done < "$req_file"

    echo "${packages# }"
}

select_requirements_file() {
    # Interactive selection of requirements.txt file
    # Sets SELECTED_REQ_FILE global variable
    # Returns: 0 on success, 1 on cancel

    echo ""
    echo -e "${CYAN}â”â”â” Import from requirements.txt â”â”â”${NC}"
    echo ""

    local file_paths=()
    local display_names=()

    while IFS='|' read -r path name; do
        [ -z "$path" ] && continue
        file_paths+=("$path")
        display_names+=("$name")
    done < <(scan_requirements_files)

    if [ ${#file_paths[@]} -eq 0 ]; then
        echo -e "${YELLOW}No requirements.txt files found in:${NC}"
        echo "  - ~/workspace/*/"
        echo "  - ~/"
        echo ""
        read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
        read -p "Enter path to requirements.txt (or press Enter to cancel): " MANUAL_PATH </dev/tty

        if [ -z "$MANUAL_PATH" ]; then
            return 1
        fi

        # Expand ~ if present
        MANUAL_PATH="${MANUAL_PATH/#\~/$HOME}"

        if validate_requirements_file "$MANUAL_PATH"; then
            SELECTED_REQ_FILE="$MANUAL_PATH"
            return 0
        else
            return 1
        fi
    fi

    echo -e "${BOLD}Found requirements.txt files:${NC}"
    echo ""

    local i=1
    for name in "${display_names[@]}"; do
        local short_path="${file_paths[$((i-1))]/#$HOME/~}"
        echo -e "  ${BOLD}$i)${NC} $name"
        echo -e "     ${DIM}$short_path${NC}"
        ((i++))
    done
    echo -e "  ${BOLD}$i)${NC} Enter path manually"
    ((i++))
    echo -e "  ${BOLD}$i)${NC} Cancel"
    echo ""

    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
    read -p "Choice [1-$i]: " CHOICE </dev/tty

    # Cancel option
    if [ "$CHOICE" = "$i" ]; then
        return 1
    fi

    # Manual entry option
    if [ "$CHOICE" = "$((i-1))" ]; then
        echo ""
        read -p "Enter path to requirements.txt: " MANUAL_PATH </dev/tty
        MANUAL_PATH="${MANUAL_PATH/#\~/$HOME}"

        if [ -z "$MANUAL_PATH" ]; then
            return 1
        fi

        if validate_requirements_file "$MANUAL_PATH"; then
            SELECTED_REQ_FILE="$MANUAL_PATH"
            return 0
        else
            return 1
        fi
    fi

    # Validate selection
    if ! [[ "$CHOICE" =~ ^[0-9]+$ ]] || [ "$CHOICE" -lt 1 ] || [ "$CHOICE" -gt "${#file_paths[@]}" ]; then
        echo -e "${RED}Invalid selection${NC}"
        return 1
    fi

    local selected_path="${file_paths[$((CHOICE-1))]}"

    if validate_requirements_file "$selected_path"; then
        SELECTED_REQ_FILE="$selected_path"
        return 0
    else
        return 1
    fi
}

# ============================================================================
# End Requirements.txt Import Functions
# ============================================================================

# Find available text editor
find_editor() {
    # Try these editors in order
    for editor in "${EDITOR:-}" vim vi nano emacs; do
        if [ -n "$editor" ] && command -v "$editor" &> /dev/null; then
            echo "$editor"
            return 0
        fi
    done
    # Fallback to cat for viewing if no editor found
    echo "cat"
    return 1
}

# Custom image selection function
select_image_interactive() {
    while true; do
        # All display output goes to stderr so it's visible to user
        echo "" >&2
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}" >&2
        echo -e "${BOLD}Your Docker Images${NC}" >&2
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}" >&2

        # Get list of user's images - filter by DS01 naming pattern
        local images=()
        local user_id=$(id -u)
        mapfile -t images < <(docker images --format "{{.Repository}}" 2>/dev/null | grep "^ds01-$user_id/" | grep -v "REPOSITORY")

        # Show only DS01 images in table format (use awk to preserve table formatting)
        docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.CreatedSince}}" | \
            awk -v uid="$user_id" 'NR==1 || $1 ~ "^ds01-"uid"/"' >&2

        echo "" >&2

        # Remove empty entries
        local filtered_images=()
        for img in "${images[@]}"; do
            if [ -n "$img" ]; then
                filtered_images+=("$img")
            fi
        done
        images=("${filtered_images[@]}")

        local count=${#images[@]}

        if [ "$count" -eq 0 ]; then
            echo -e "${RED}No images found${NC}" >&2
            echo "" >&2
            echo "Run ${GREEN}image-create${NC} to create your first image" >&2
            return 1
        fi

        echo -e "${BOLD}Total: $count image(s)${NC}" >&2
        echo "" >&2
        echo -e "${CYAN}Select an image to update:${NC}" >&2
        echo "" >&2

        # Display numbered list
        local i=1
        for img in "${images[@]}"; do
            echo " $i) $img" >&2
            ((i++))
        done
        echo " $i) Exit" >&2
        echo "" >&2

        read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
        read -p "Select number (or 'q' to quit): " selection </dev/tty

        # Handle exit
        if [ "$selection" = "q" ] || [ "$selection" = "$i" ]; then
            return 1
        fi

        # Validate selection
        if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -ge "$i" ]; then
            echo -e "${RED}Invalid selection. Please try again.${NC}" >&2
            sleep 1
            continue
        fi

        # Get selected image - THIS goes to stdout for capture
        local selected_image="${images[$((selection-1))]}"
        echo "$selected_image"
        return 0
    done
}

usage() {
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Docker Image Updater${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${CYAN}Usage:${NC}"
    echo "  image-update [image-name] [options]"
    echo "  image-update                                 # Prompts to select image (if none specified)"
    echo "  image-update <image-name>                    # Interactive mode (default)"
    echo ""
    echo -e "${CYAN}Options:${NC}"
    echo "  --add \"pkg1 pkg2\"       Add packages directly (quick mode)"
    echo "  -r, --requirements FILE  Import packages from requirements.txt"
    echo "  --add-system \"pkg1\"     Add system packages directly"
    echo "  --edit                  Edit Dockerfile manually (advanced)"
    echo "  --guided                Show detailed explanations (educational)"
    echo "  --no-cache              Build without using cache (clean rebuild)"
    echo "  -h, --help              Show this help message"
    echo ""
    echo -e "${CYAN}Modes:${NC}"
    echo -e "  ${BOLD}Interactive${NC} (default)  - User-friendly GUI for package management"
    echo -e "  ${BOLD}Quick${NC} (--add)          - Add packages from command line"
    echo -e "  ${BOLD}Advanced${NC} (--edit)      - Direct Dockerfile editing"
    echo -e "  ${BOLD}Guided${NC} (--guided)      - Educational mode with explanations"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo -e "  ${DIM}# Interactive mode (shows current packages, prompts for changes)${NC}"
    echo "  image-update my-project"
    echo ""
    echo -e "  ${DIM}# Quick add packages without interaction${NC}"
    echo "  image-update my-project --add \"wandb optuna pytorch-lightning\""
    echo ""
    echo -e "  ${DIM}# Import from requirements.txt${NC}"
    echo "  image-update my-project -r ~/workspace/my-project/requirements.txt"
    echo ""
    echo -e "  ${DIM}# Add system packages${NC}"
    echo "  image-update my-project --add-system \"tmux htop\""
    echo ""
    echo -e "  ${DIM}# Edit Dockerfile directly (power users)${NC}"
    echo "  image-update my-project --edit"
    echo ""
    echo -e "  ${DIM}# Guided mode for beginners${NC}"
    echo "  image-update my-project --guided"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ After updating:${NC}"
    echo "   Redeploy containers to use the new image:"
    echo -e "   ${GREEN}container-retire my-project${NC}  ${DIM}# Stop + remove${NC}"
    echo -e "   ${GREEN}container-deploy my-project${NC}  ${DIM}# Create + start${NC}"
    echo ""
    echo -e "${DIM}Run 'help' or 'commands' anytime to see available commands.${NC}"
    echo ""
}

detailed_help() {
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Docker Image Updater - Full Reference${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${BOLD}Usage:${NC}"
    echo "  image-update [image-name] [options]"
    echo "  image-update                    # Interactive selection"
    echo ""
    echo -e "${BOLD}Positional Arguments:${NC}"
    echo "  image-name        Image to update (can be short name or full path)"
    echo "                    Short: my-project"
    echo "                    Full: ds01-\${USER_ID}/my-project"
    echo ""
    echo -e "${BOLD}Options:${NC}"
    echo "  --add \"pkg1 pkg2\"        Add Python packages (space-separated)"
    echo "  -r, --requirements FILE   Import packages from requirements.txt"
    echo "  --add-system \"pkg1\"      Add system packages (apt packages)"
    echo "  --edit                   Open Dockerfile in editor"
    echo "  --guided                 Educational mode with explanations"
    echo "  --no-cache               Full rebuild without Docker cache"
    echo "  --concepts               Show pre-run educational content"
    echo "  --info                   Show this detailed reference"
    echo "  -h, --help               Show quick reference"
    echo ""
    echo -e "${BOLD}Modes:${NC}"
    echo ""
    echo -e "  ${CYAN}Interactive${NC} (default)"
    echo "    Visual package management: view, add, remove packages"
    echo "    Best for: Exploring and managing packages interactively"
    echo ""
    echo -e "  ${CYAN}Quick${NC} (--add / --add-system)"
    echo "    Command-line package additions"
    echo "    Best for: Scripting, quick additions"
    echo ""
    echo -e "  ${CYAN}Advanced${NC} (--edit)"
    echo "    Direct Dockerfile editing in your editor"
    echo "    Best for: Complex customizations"
    echo ""
    echo -e "  ${CYAN}Guided${NC} (--guided)"
    echo "    Step-by-step with explanations"
    echo "    Best for: Learning, first-time users"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo ""
    echo -e "  ${DIM}# Interactive mode with visual package management${NC}"
    echo "  image-update my-project"
    echo ""
    echo -e "  ${DIM}# Quick add Python packages${NC}"
    echo "  image-update my-project --add \"wandb optuna\""
    echo ""
    echo -e "  ${DIM}# Add multiple with version specifiers${NC}"
    echo "  image-update my-project --add \"numpy>=1.24 pandas==2.0.0\""
    echo ""
    echo -e "  ${DIM}# Add system packages${NC}"
    echo "  image-update my-project --add-system \"tmux htop git-lfs\""
    echo ""
    echo -e "  ${DIM}# Edit Dockerfile directly${NC}"
    echo "  image-update my-project --edit"
    echo ""
    echo -e "  ${DIM}# Clean rebuild (no cache)${NC}"
    echo "  image-update my-project --no-cache"
    echo ""
    echo -e "  ${DIM}# Combine: add packages + clean rebuild${NC}"
    echo "  image-update my-project --add \"new-pkg\" --no-cache"
    echo ""
    echo -e "${BOLD}After Updating:${NC}"
    echo "  Redeploy containers to use the updated image:"
    echo -e "  1. ${GREEN}container-retire my-project${NC}   ${DIM}# Remove old container${NC}"
    echo -e "  2. ${GREEN}container-deploy my-project${NC}   ${DIM}# Create with new image${NC}"
    echo ""
    echo -e "${BOLD}Related Commands:${NC}"
    echo -e "  ${GREEN}image-create${NC}   Create a new image from scratch"
    echo -e "  ${GREEN}image-list${NC}     View all your images"
    echo -e "  ${GREEN}image-delete${NC}   Remove an image"
    echo ""
}

show_concepts() {
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Understanding Image Updates${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${BOLD}What does image-update do?${NC}"
    echo "  Rebuilds an existing Docker image after modifying its Dockerfile."
    echo "  Use this to add, remove, or change packages in your environment."
    echo ""
    echo -e "${BOLD}Key Terms:${NC}"
    echo -e "  â€¢ ${CYAN}Dockerfile${NC} - Recipe file that defines your image"
    echo -e "  â€¢ ${CYAN}Image${NC} - Built environment (frozen, reusable)"
    echo -e "  â€¢ ${CYAN}Rebuild${NC} - Create new image version from Dockerfile"
    echo ""
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo ""
    echo -e "${BOLD}When to use image-update vs image-create:${NC}"
    echo ""
    echo -e "  ${GREEN}image-create${NC} - Starting fresh"
    echo "    â€¢ First-time image creation"
    echo "    â€¢ Changing base framework (PyTorch â†’ TensorFlow)"
    echo "    â€¢ Starting over with different packages"
    echo ""
    echo -e "  ${GREEN}image-update${NC} - Modifying existing"
    echo "    â€¢ Adding new packages"
    echo "    â€¢ Removing packages"
    echo "    â€¢ Updating package versions"
    echo ""
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo ""
    echo -e "${BOLD}How Docker Caching Works:${NC}"
    echo "  Docker caches each layer to speed up rebuilds."
    echo "  Only changed layers get rebuilt."
    echo ""
    echo "  If a rebuild seems wrong:"
    echo -e "  â€¢ Use ${GREEN}--no-cache${NC} for a clean rebuild"
    echo "  â€¢ This takes longer but ensures fresh packages"
    echo ""
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo ""
    echo -e "${BOLD}After Updating:${NC}"
    echo "  Existing containers still use the OLD image."
    echo "  To use the updated image, redeploy:"
    echo -e "  1. ${GREEN}container-retire my-project${NC}"
    echo -e "  2. ${GREEN}container-deploy my-project${NC}"
    echo ""
    echo -e "${BOLD}Ready to start?${NC}"
    echo -e "  Run: ${GREEN}image-update${NC}              (select image interactively)"
    echo -e "  Run: ${GREEN}image-update my-project${NC}   (update specific image)"
    echo ""
}

# Parse Dockerfile to extract Python packages (simple list)
parse_python_packages() {
    local dockerfile="$1"

    # Extract all lines between "RUN pip install" and the next empty line or next RUN command
    # Handles both single-line and multi-line pip install blocks
    awk '
    /^RUN pip install/ {
        # Extract packages from the same line (single-line format)
        line = $0
        sub(/^RUN pip install[[:space:]]+(--no-cache-dir[[:space:]]+)?/, "", line)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
        if (line != "") {
            # Single-line format: print packages from this line
            split(line, pkgs, /[[:space:]]+/)
            for (i in pkgs) {
                if (pkgs[i] != "" && pkgs[i] !~ /^--/) {
                    print pkgs[i]
                }
            }
        }
        in_pip=1
        next
    }
    in_pip {
        if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
            in_pip=0
        } else {
            # Multi-line format: extract packages from continuation lines
            gsub(/^[[:space:]]+/, "")
            gsub(/[[:space:]]*\\[[:space:]]*$/, "")
            if ($0 != "" && $0 !~ /^--/) {
                print $0
            }
        }
    }
    ' "$dockerfile" | sort -u
}

# Parse Dockerfile to extract categorized Python packages
parse_python_packages_by_category() {
    local dockerfile="$1"

    # Extract packages organized by their comment sections (matching image-create structure)
    awk '
    /^# Jupyter & Interactive/ || /^# Jupyter.*Interactive/ { category="jupyter"; next }
    /^# Core Data Science/ { category="datascience"; next }
    /^# Core Python packages/ { category="core"; next }
    /^# Use case specific packages/ { category="usecase"; next }
    /^# Custom additional packages/ || /^# Additional.*packages/ { category="custom"; next }
    /^RUN pip install/ {
        in_pip=1
        # Extract packages from the same line (single-line format)
        line = $0
        sub(/^RUN pip install[[:space:]]+(--no-cache-dir[[:space:]]+)?/, "", line)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
        if (line != "") {
            split(line, pkgs, /[[:space:]]+/)
            for (i in pkgs) {
                if (pkgs[i] != "" && pkgs[i] !~ /^--/ && category != "") {
                    print category ":" pkgs[i]
                }
            }
        }
        next
    }
    in_pip {
        if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
            in_pip=0
            category=""
        } else {
            gsub(/^[[:space:]]+/, "")
            gsub(/[[:space:]]*\\[[:space:]]*$/, "")
            if ($0 != "" && $0 !~ /^--/ && category != "") {
                print category ":" $0
            }
        }
    }
    ' "$dockerfile"
}

# Parse Dockerfile to extract system packages
parse_system_packages() {
    local dockerfile="$1"

    # Extract system packages from apt-get install blocks (handles multi-line)
    awk '
    /apt-get install/ {
        in_apt=1
        # Extract packages from the same line if any
        line = $0
        sub(/.*apt-get install[[:space:]]+(-y[[:space:]]+)?(--no-install-recommends[[:space:]]+)?/, "", line)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
        gsub(/&&.*/, "", line)
        if (line != "") {
            split(line, pkgs, /[[:space:]]+/)
            for (i in pkgs) {
                if (pkgs[i] != "" && pkgs[i] !~ /^-/ && pkgs[i] != "apt-get" && pkgs[i] != "update") {
                    print pkgs[i]
                }
            }
        }
        next
    }
    in_apt {
        if (/&&/ || /^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
            in_apt=0
        } else {
            # Extract packages from continuation lines
            line = $0
            gsub(/^[[:space:]]+/, "", line)
            gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
            gsub(/&&.*/, "", line)
            if (line != "" && line !~ /^-/ && line != "apt-get" && line != "update" && line != "rm") {
                print line
            }
        }
    }
    ' "$dockerfile" | sort -u
}

# Add Python packages to Dockerfile
# Returns: 0 if packages added, 1 if error, sets PACKAGES_ADDED_COUNT
add_python_packages() {
    local dockerfile="$1"
    shift
    local packages=("$@")
    PACKAGES_ADDED_COUNT=0

    # Find "# Custom additional packages" section
    local custom_line=$(grep -n "^# Custom additional packages" "$dockerfile" | cut -d: -f1)

    if [ -z "$custom_line" ]; then
        echo -e "${RED}âœ— Could not find '# Custom additional packages' section in Dockerfile${NC}"
        return 1
    fi

    # Create backup
    cp "$dockerfile" "${dockerfile}.bak"

    # Check if there's already a RUN pip install after the custom comment
    local next_line=$((custom_line + 1))
    local next_line_content=$(sed -n "${next_line}p" "$dockerfile")

    local last_pip_line=""
    local is_multiline=false

    if [[ "$next_line_content" =~ ^RUN\ pip\ install ]]; then
        # There's already a RUN pip install in the custom section
        last_pip_line=$next_line
        if [[ "$next_line_content" =~ \\[[:space:]]*$ ]]; then
            is_multiline=true
        fi
    else
        # No RUN pip install yet - insert one after the comment
        sed -i "${custom_line}a\\RUN pip install --no-cache-dir \\\\" "$dockerfile"
        last_pip_line=$((custom_line + 1))
        is_multiline=true
    fi

    # Add packages
    for pkg in "${packages[@]}"; do
        # Extract base package name (remove version specifiers like ==, >=, etc.)
        local pkg_base=$(echo "$pkg" | sed 's/[=><!].*//')

        # Check if package already exists by parsing the dockerfile properly
        if parse_python_packages "$dockerfile" | grep -qxi "$pkg_base"; then
            echo -e "${YELLOW}  âš  $pkg_base already in Dockerfile, skipping${NC}"
            echo ""
            continue
        fi

        if [ "$is_multiline" = true ]; then
            # Multi-line format: Find the last package line (line before empty line or next section)
            # and add backslash to it if it doesn't have one, then insert new package without backslash
            local next_empty_line=$(awk -v start="$last_pip_line" 'NR > start && /^$/ {print NR; exit}' "$dockerfile")
            local next_run_line=$(awk -v start="$last_pip_line" 'NR > start && /^RUN/ {print NR; exit}' "$dockerfile")
            local next_comment_line=$(awk -v start="$last_pip_line" 'NR > start && /^#/ {print NR; exit}' "$dockerfile")

            # Find which comes first (the end of this pip block)
            local end_line=""
            if [ -n "$next_empty_line" ]; then
                end_line=$next_empty_line
            fi
            if [ -n "$next_run_line" ] && { [ -z "$end_line" ] || [ "$next_run_line" -lt "$end_line" ]; }; then
                end_line=$next_run_line
            fi
            if [ -n "$next_comment_line" ] && { [ -z "$end_line" ] || [ "$next_comment_line" -lt "$end_line" ]; }; then
                end_line=$next_comment_line
            fi

            if [ -n "$end_line" ]; then
                local insert_line=$((end_line - 1))
                # Check if the line before end has a backslash
                if ! sed -n "${insert_line}p" "$dockerfile" | grep -q '\\$'; then
                    # Add backslash to previous last line
                    sed -i "${insert_line}s/$/ \\\\/" "$dockerfile"
                fi
                # Insert new package without backslash after the previous last line
                sed -i "${insert_line}a\\    $pkg" "$dockerfile"
            else
                # No end found, just append with backslash
                sed -i "${last_pip_line}a\\    $pkg \\\\" "$dockerfile"
            fi
        else
            # Single-line format: convert to multi-line and add package
            # Replace the RUN line to add backslash, then add package on next line without backslash
            sed -i "${last_pip_line}s/$/ \\\\/" "$dockerfile"
            sed -i "${last_pip_line}a\\    $pkg" "$dockerfile"
            is_multiline=true  # Now it's multi-line for subsequent packages
        fi

        echo -e "${GREEN}  âœ“${NC} Added: $pkg"
        PACKAGES_ADDED_COUNT=$((PACKAGES_ADDED_COUNT + 1))
    done

    # Show summary after adding all packages
    if [ "$PACKAGES_ADDED_COUNT" -gt 0 ]; then
        echo ""
        echo -e "${GREEN}âœ“${NC} Added $PACKAGES_ADDED_COUNT package(s) to Dockerfile"
        echo ""
        echo -e "Updated Dockerfile: ${BLUE}$dockerfile${NC}"
        echo ""
    fi

    return 0
}

# Add system packages to Dockerfile
add_system_packages() {
    local dockerfile="$1"
    shift
    local packages=("$@")

    # Find the apt-get install line
    local apt_line=$(grep -n "apt-get install" "$dockerfile" | head -1 | cut -d: -f1)

    if [ -z "$apt_line" ]; then
        echo -e "${RED}âœ— Could not find apt-get install section in Dockerfile${NC}"
        return 1
    fi

    # Create backup
    cp "$dockerfile" "${dockerfile}.bak"

    # Add packages to apt-get install line
    for pkg in "${packages[@]}"; do
        # Check if package already exists
        if grep -q "$pkg" "$dockerfile"; then
            echo -e "${YELLOW}  âš  $pkg already in Dockerfile, skipping${NC}"
            continue
        fi

        # Insert package in apt-get install line
        sed -i "${apt_line}s/$/ \\\\\n    $pkg/" "$dockerfile"
        echo -e "${GREEN}  âœ“${NC} Added: $pkg"
    done

    return 0
}

# Remove packages from Dockerfile
remove_packages() {
    local dockerfile="$1"
    shift
    local packages=("$@")

    cp "$dockerfile" "${dockerfile}.bak"

    for pkg in "${packages[@]}"; do
        # Extract base package name (remove version specifiers)
        local pkg_base=$(echo "$pkg" | sed 's/[=><!~].*//')

        # Only remove lines that are part of pip install blocks and match the package as a whole word
        # This prevents accidentally removing lines like "torchvision" when trying to remove "torch"
        local removed=false

        # Find all pip install blocks and remove matching package lines
        awk -v pkg="$pkg_base" '
        BEGIN { in_pip=0 }
        /^RUN pip install/ { in_pip=1; print; next }
        in_pip {
            # Check if end of pip block
            if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
                in_pip=0
                print
                next
            }
            # Extract package name from line (remove leading spaces and trailing backslash)
            line_pkg = $0
            gsub(/^[[:space:]]+/, "", line_pkg)
            gsub(/[[:space:]]*\\[[:space:]]*$/, "", line_pkg)
            gsub(/[=><!~].*/, "", line_pkg)  # Remove version specifiers

            # Only skip this line if it matches the package exactly
            if (line_pkg == pkg) {
                next  # Skip this line (effectively removing it)
            }
            print
        }
        !in_pip { print }
        ' "$dockerfile" > "${dockerfile}.tmp" && mv "${dockerfile}.tmp" "$dockerfile"

        if ! diff -q "${dockerfile}.bak" "$dockerfile" > /dev/null 2>&1; then
            echo -e "${GREEN}  âœ“${NC} Removed: $pkg"
            removed=true
        else
            echo -e "${YELLOW}  âš ${NC} Package not found: $pkg"
        fi
    done

    # Clean up empty RUN pip install blocks that have no packages
    # This prevents Docker build errors from empty pip install commands
    awk '
    BEGIN {
        in_pip=0
        pip_start_line=0
        pip_has_packages=0
        buffer=""
        buffer_count=0
    }
    /^RUN pip install/ {
        # Flush previous pip block if needed
        if (in_pip && pip_has_packages) {
            print buffer
        }
        # Start new pip block
        in_pip=1
        pip_start_line=NR
        pip_has_packages=0
        buffer=$0 "\n"
        buffer_count=1
        next
    }
    in_pip {
        # Check if end of pip block
        if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/ || /^FROM/) {
            # End of pip block - print buffer only if it has packages
            if (pip_has_packages) {
                print buffer $0
            } else {
                print "# [Removed empty pip install block]"
                print $0
            }
            in_pip=0
            buffer=""
            buffer_count=0
            next
        }

        # Inside pip block - check if line has a package
        line_stripped = $0
        gsub(/^[[:space:]]+/, "", line_stripped)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line_stripped)

        if (line_stripped != "" && line_stripped !~ /^--/) {
            pip_has_packages=1
        }

        buffer = buffer $0 "\n"
        buffer_count++
        next
    }
    !in_pip {
        print
    }
    END {
        # Handle last pip block if file ends in one
        if (in_pip && pip_has_packages) {
            printf "%s", buffer
        }
    }
    ' "$dockerfile" > "${dockerfile}.tmp" && mv "${dockerfile}.tmp" "$dockerfile"

    # Check if any empty blocks were removed
    if grep -q "# \[Removed empty pip install block\]" "$dockerfile"; then
        echo -e "${YELLOW}  â„¹${NC} Removed empty pip install block (prevents build errors)"
        # Clean up the marker comments
        sed -i '/# \[Removed empty pip install block\]/d' "$dockerfile"
    fi

    return 0
}

# Interactive mode
interactive_mode() {
    local dockerfile="$1"

    while true; do

        # Show current packages categorized
        echo ""
        echo -e "${BOLD}Current Configuration:${NC}"
        echo ""

        # AIME base image (from FROM line)
        local base_image=$(grep "^FROM " "$dockerfile" | head -1 | sed 's/FROM //')
        if [ -n "$base_image" ]; then
            echo -e "  ${BOLD}â€¢ AIME Base Image:${NC} ${GREEN}$base_image${NC}"

            # Show key packages from AIME base (if it's an AIME image)
            if [[ "$base_image" =~ aimehub/ ]]; then
                echo -e "    â€¢ ${DIM}Pre-installed: torch, numpy, pillow, tqdm, conda, ipython, psutil${NC}"
                echo -e "    â€¢ ${DIM}(Use 'docker run --rm $base_image pip list' to see all)${NC}"
            fi
        fi

        # System packages
        local sys_pkgs=$(parse_system_packages "$dockerfile" | tr '\n' ' ')
        if [ -n "$sys_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}System:${NC} $sys_pkgs"
        else
            echo -e "  â€¢ ${BOLD}System:${NC} ${DIM}(none)${NC}"
        fi

        # Parse categorized Python packages (matching image-create structure)
        local jupyter_pkgs=""
        local datascience_pkgs=""
        local core_pkgs=""  # Legacy category for old Dockerfiles
        local usecase_pkgs=""
        local custom_pkgs=""

        while IFS=: read -r category pkg; do
            case "$category" in
                jupyter) jupyter_pkgs="$jupyter_pkgs $pkg" ;;
                datascience) datascience_pkgs="$datascience_pkgs $pkg" ;;
                core) core_pkgs="$core_pkgs $pkg" ;;  # Legacy
                usecase) usecase_pkgs="$usecase_pkgs $pkg" ;;
                custom) custom_pkgs="$custom_pkgs $pkg" ;;
            esac
        done < <(parse_python_packages_by_category "$dockerfile")

        # Display Python packages by category (new structure from image-create)
        if [ -n "$jupyter_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Jupyter & Interactive:${NC}$jupyter_pkgs"
        elif [ -n "$core_pkgs" ]; then
            # Legacy: old Dockerfiles had everything as "core"
            echo -e "  â€¢ ${BOLD}Core Python:${NC}$core_pkgs ${DIM}(legacy format)${NC}"
        else
            echo -e "  â€¢ ${BOLD}Jupyter & Interactive:${NC} ${DIM}(none)${NC}"
        fi

        if [ -n "$datascience_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Data Science:${NC}$datascience_pkgs"
        else
            echo -e "  â€¢ ${BOLD}Data Science:${NC} ${DIM}(none)${NC}"
        fi

        if [ -n "$usecase_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Use Case Specific:${NC}$usecase_pkgs"
        else
            echo -e "  â€¢ ${BOLD}Use Case Specific:${NC} ${DIM}(none)${NC}"
        fi

        if [ -n "$custom_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Custom-installed:${NC}$custom_pkgs"
        else
            echo -e "  â€¢ ${BOLD}Custom-installed:${NC} ${DIM}(none)${NC}"
        fi

        echo ""

        echo -e "${BOLD}What would you like to do?${NC}"
        echo ""
        echo -e "  ${BOLD}1)${NC} Add Python packages (pip)"
        echo -e "  ${BOLD}2)${NC} Import from requirements.txt"
        echo -e "  ${BOLD}3)${NC} Add system packages (apt)"
        echo -e "  ${BOLD}4)${NC} Remove packages"
        echo -e "  ${BOLD}5)${NC} Edit Dockerfile directly ${DIM}(advanced)${NC}"
        echo -e "  ${BOLD}6)${NC} Continue to rebuild ${BOLD}${YELLOW}(necessary to apply changes!)${NC}"
        echo -e "  ${BOLD}7)${NC} Cancel"
        echo ""
        read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
        read -p "Choice [1-7]: " CHOICE </dev/tty

        case $CHOICE in
            1)
                # Loop until no duplicates
                while true; do
                    echo ""
                    echo -e "${BOLD}Add Python Packages${NC}"
                    echo ""
                    echo "Enter package names (space-separated):"
                    echo -e "${DIM}Examples: wandb optuna pytorch-lightning pandas==1.5.3 transformers>=4.30.0${NC}"
                    echo ""
                    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                    read -p "> " NEW_PACKAGES </dev/tty

                    if [ -z "$NEW_PACKAGES" ]; then
                        echo -e "${YELLOW}No packages entered${NC}"
                        break
                    fi

                    # Get all currently installed packages
                    local aime_base="numpy pillow tqdm conda ipython psutil torch torchvision torchaudio"
                    local all_current=""
                    if [ -n "$jupyter_pkgs" ]; then
                        all_current="$all_current $jupyter_pkgs"
                    fi
                    if [ -n "$datascience_pkgs" ]; then
                        all_current="$all_current $datascience_pkgs"
                    fi
                    if [ -n "$core_pkgs" ]; then
                        all_current="$all_current $core_pkgs"
                    fi
                    if [ -n "$usecase_pkgs" ]; then
                        all_current="$all_current $usecase_pkgs"
                    fi
                    if [ -n "$custom_pkgs" ]; then
                        all_current="$all_current $custom_pkgs"
                    fi

                    # Check for duplicates
                    local duplicates=$(check_duplicate_packages "$NEW_PACKAGES" "$aime_base" "$all_current")

                    if [ $? -eq 1 ]; then
                        echo ""
                        echo -e "${YELLOW}âš   Warning: These packages are already installed:${NC}"
                        echo -e "   ${YELLOW}$duplicates${NC}"
                        echo ""
                        echo "Please enter different packages (or press Enter to cancel):"
                    else
                        # No duplicates, proceed with adding
                        echo ""
                        echo -e "${CYAN}Adding packages...${NC}"
                        echo ""
                        add_python_packages "$dockerfile" $NEW_PACKAGES
                        if [ "$PACKAGES_ADDED_COUNT" -gt 0 ]; then
                            echo -e "${YELLOW}ğŸ’¡ To apply changes, you'll need to rebuild the image based on the updated Dockerfile.${NC}"
                            echo ""
                            read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                            read -p "Rebuild now? [Y/n]: " REBUILD_NOW </dev/tty
                            REBUILD_NOW=${REBUILD_NOW:-Y}
                            if [[ "$REBUILD_NOW" =~ ^[Yy]$ ]]; then
                                echo ""
                                return 0  # Exit interactive mode to proceed to rebuild
                            fi
                        fi
                        break
                    fi
                done
                ;;

            2)
                # Import from requirements.txt
                if select_requirements_file; then
                    local req_packages=$(read_requirements_packages "$SELECTED_REQ_FILE")
                    local pkg_count=$(echo "$req_packages" | wc -w)
                    local short_path="${SELECTED_REQ_FILE/#$HOME/~}"

                    echo ""
                    echo -e "${GREEN}âœ“${NC} Will install ${BOLD}$pkg_count${NC} packages from: ${CYAN}$short_path${NC}"
                    echo ""
                    echo -e "${DIM}Packages: $req_packages${NC}"
                    echo ""
                    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                    read -p "Add these packages? [Y/n]: " CONFIRM </dev/tty
                    CONFIRM=${CONFIRM:-Y}

                    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
                        echo ""
                        echo -e "${CYAN}Adding packages...${NC}"
                        add_python_packages "$dockerfile" $req_packages
                        echo ""
                        echo -e "${GREEN}âœ“${NC} Packages from requirements.txt added to Dockerfile"
                        echo ""
                        echo -e "${YELLOW}ğŸ’¡ To apply changes, you'll need to rebuild the image.${NC}"
                        echo ""
                        read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                        read -p "Rebuild now? [Y/n]: " REBUILD_NOW </dev/tty
                        REBUILD_NOW=${REBUILD_NOW:-Y}
                        if [[ "$REBUILD_NOW" =~ ^[Yy]$ ]]; then
                            echo ""
                            return 0
                        fi
                    fi
                fi
                ;;

            3)
                echo ""
                echo -e "${BOLD}Add System Packages${NC}"
                echo ""
                echo "Enter system package names (space-separated):"
                echo -e "${DIM}Examples: tmux htop tree${NC}"
                echo ""
                read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                read -p "> " NEW_SYS_PACKAGES </dev/tty

                if [ -n "$NEW_SYS_PACKAGES" ]; then
                    echo ""
                    echo -e "${CYAN}Adding system packages...${NC}"
                    echo ""
                    add_system_packages "$dockerfile" $NEW_SYS_PACKAGES
                    echo ""
                    echo -e "${GREEN}âœ“${NC} System packages added to Dockerfile"
                    echo ""
                    echo -e "${YELLOW}ğŸ’¡ To apply changes, you'll need to rebuild the image based on the updated Dockerfile.${NC}"
                    echo ""
                    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                    read -p "Rebuild now? [Y/n]: " REBUILD_NOW </dev/tty
                    REBUILD_NOW=${REBUILD_NOW:-Y}
                    if [[ "$REBUILD_NOW" =~ ^[Yy]$ ]]; then
                        echo ""
                        return 0  # Exit interactive mode to proceed to rebuild
                    fi
                else
                    echo -e "${YELLOW}No packages entered${NC}"
                fi
                ;;

            4)
                echo ""
                echo -e "${BOLD}Remove Packages${NC}"
                echo ""
                echo "Enter package names to remove (space-separated):"
                echo ""
                read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                read -p "> " REMOVE_PACKAGES </dev/tty

                if [ -n "$REMOVE_PACKAGES" ]; then
                    echo ""
                    echo -e "${CYAN}Removing packages...${NC}"
                    echo ""
                    remove_packages "$dockerfile" $REMOVE_PACKAGES
                    echo ""
                    echo -e "${GREEN}âœ“${NC} Packages removed from Dockerfile"
                    echo ""
                    echo -e "${YELLOW}ğŸ’¡ To apply changes, you'll need to rebuild the image based on the updated Dockerfile.${NC}"
                    echo ""
                    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                    read -p "Rebuild now? [Y/n]: " REBUILD_NOW </dev/tty
                    REBUILD_NOW=${REBUILD_NOW:-Y}
                    if [[ "$REBUILD_NOW" =~ ^[Yy]$ ]]; then
                        echo ""
                        return 0  # Exit interactive mode to proceed to rebuild
                    fi
                else
                    echo -e "${YELLOW}No packages entered${NC}"
                    echo ""
                fi
                ;;

            5)
                echo ""
                EDITOR_CMD=$(find_editor)
                if [ "$EDITOR_CMD" = "cat" ]; then
                    echo -e "${RED}âœ— No text editor found${NC}"
                    echo ""
                    echo "Please install one of: vim, vi, nano, emacs"
                    echo "Or set EDITOR environment variable to your preferred editor"
                    echo ""
                    echo "For now, displaying Dockerfile content:"
                    echo ""
                    cat "$dockerfile"
                    echo ""
                    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
                    read -p "Press Enter to continue..." </dev/tty
                else
                    echo -e "${YELLOW}Opening Dockerfile in $EDITOR_CMD...${NC}"
                    echo ""
                    "$EDITOR_CMD" "$dockerfile"
                    echo ""
                    echo -e "${GREEN}âœ“${NC} Dockerfile edited"
                fi
                ;;

            6)
                echo ""
                return 0
                ;;

            7)
                echo ""
                echo "Cancelled."
                exit 0
                ;;

            *)
                echo -e "${RED}Invalid choice${NC}"
                ;;
        esac
    done
}

# Guided mode with educational content
guided_mode() {
    local dockerfile="$1"

    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Docker Image Updates - Guided Mode${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${BOLD}Understanding Docker Images${NC}"
    echo ""
    echo -e "A Docker image is like a ${CYAN}blueprint${NC} for your computing environment."
    echo "It defines what software, packages, and tools are installed."
    echo ""
    echo -e "${BOLD}Why Can't I Just 'pip install' in My Container?${NC}"
    echo ""
    echo -e "${YELLOW}You can, BUT:${NC}"
    echo ""
    echo -e "  ${CYAN}Temporary Install${NC} (pip install in container):"
    echo "    âœ“ Fast for testing"
    echo "    âœ“ No rebuild needed"
    echo "    âœ— Lost when container is removed"
    echo "    âœ— Not reproducible"
    echo "    âœ— Can't share with colleagues"
    echo ""
    echo -e "  ${GREEN}Permanent Install${NC} (update image):"
    echo "    âœ“ Persists across container recreations"
    echo "    âœ“ Reproducible setup"
    echo "    âœ“ Can share with team"
    echo "    âœ“ Documented in Dockerfile"
    echo "    âœ— Takes 3-5 minutes to rebuild"
    echo ""
    echo -e "${BOLD}Best Practice Workflow:${NC}"
    echo ""
    echo -e "  1. ${CYAN}Test${NC} new packages: pip install in container"
    echo -e "  2. ${CYAN}Confirm${NC} they work: run your code"
    echo -e "  3. ${CYAN}Make permanent${NC}: image-update (this command)"
    echo -e "  4. ${CYAN}Recreate/deploy${NC} container with updated image"
    echo ""
    echo -e "${BOLD}What This Command Does:${NC}"
    echo ""
    echo "  â€¢ Shows packages currently in your image"
    echo "  â€¢ Lets you add/remove packages easily"
    echo "  â€¢ Updates the Dockerfile automatically"
    echo "  â€¢ Rebuilds the image with your changes"
    echo "  â€¢ Creates a permanent, reproducible setup"
    echo ""
    echo -e "${BOLD}Package Versions:${NC}"
    echo ""
    echo -e "  â€¢ ${CYAN}Without version${NC}: 'pandas' â†’ installs latest stable"
    echo -e "  â€¢ ${CYAN}Exact version${NC}: 'pandas==1.5.3' â†’ installs 1.5.3"
    echo -e "  â€¢ ${CYAN}Minimum version${NC}: 'pandas>=2.0.0' â†’ installs latest â‰¥2.0.0"
    echo -e "  â€¢ ${CYAN}Compatible${NC}: 'pandas~=1.5.0' â†’ installs latest 1.5.x"
    echo ""
    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
    read -p "Press Enter to continue..." </dev/tty
    echo ""

    # Now run interactive mode
    interactive_mode "$dockerfile"
}

# Parse arguments
IMAGE_NAME=""
EDIT_FIRST=false
NO_CACHE=false
QUICK_ADD_PACKAGES=""
QUICK_ADD_SYSTEM=""
REQUIREMENTS_FILE=""
GUIDED=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --add)
            QUICK_ADD_PACKAGES="$2"
            shift 2
            ;;
        -r|--requirements)
            REQUIREMENTS_FILE="$2"
            shift 2
            ;;
        --add-system)
            QUICK_ADD_SYSTEM="$2"
            shift 2
            ;;
        --edit)
            EDIT_FIRST=true
            shift
            ;;
        --guided)
            GUIDED=true
            shift
            ;;
        --no-cache)
            NO_CACHE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --info)
            detailed_help
            exit 0
            ;;
        --concepts)
            show_concepts
            exit 0
            ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}\n"
            usage
            exit 1
            ;;
        *)
            if [ -z "$IMAGE_NAME" ]; then
                IMAGE_NAME="$1"
            else
                echo -e "${RED}Multiple image names specified${NC}\n"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

# If no image name provided, prompt to select
if [ -z "$IMAGE_NAME" ]; then
    IMAGE_NAME=$(select_image_interactive)
    if [ $? -ne 0 ] || [ -z "$IMAGE_NAME" ]; then
        echo "No selection made. Exiting."
        exit 0
    fi
    echo ""
fi

# Validate image name
if [ -z "$IMAGE_NAME" ]; then
    echo -e "${RED}Error: Image name is required${NC}\n"
    usage
    exit 1
fi

# Check if image exists
USER_ID=$(id -u)
GROUP_ID=$(id -g)
# Source username utilities and sanitize (handles @, ., and 32-char limit)
source "/opt/ds01-infra/scripts/lib/username-utils.sh"
SANITIZED_USERNAME=$(sanitize_username_for_slice "$USERNAME")

if docker images --format "{{.Repository}}" | grep -q "^${IMAGE_NAME}$"; then
    # Image exists as-is (full path like ds01-1001/my-project)
    :
elif [[ ! "$IMAGE_NAME" =~ ^ds01- ]]; then
    # Add DS01 prefix: ds01-{user-id}/{project}
    IMAGE_NAME="ds01-${USER_ID}/${IMAGE_NAME}"
    if ! docker images --format "{{.Repository}}" | grep -q "^${IMAGE_NAME}$"; then
        # Image doesn't exist, show error
        echo -e "${RED}âœ— Image '$IMAGE_NAME' not found${NC}\n"
        echo "Available images:"
        echo ""
        # Use image-list command to show available images properly
        if command -v image-list &> /dev/null; then
            image-list 2>/dev/null || docker images --format "  {{.Repository}}" | grep "^ds01-$USER_ID/"
        else
            docker images --format "  {{.Repository}}" | grep "^ds01-$USER_ID/"
        fi
        echo ""
        echo -e "Create new image with: ${GREEN}image-create${NC}"
        exit 1
    fi
fi

# Find Dockerfile
DOCKERFILE=""

# Check info file first (sanitize filename - replace / with _)
METADATA_FILE=$(echo "$IMAGE_NAME" | tr '/' '_')
INFO_FILE="$HOME/ds01-config/images/${METADATA_FILE}.info"
if [ -f "$INFO_FILE" ]; then
    DOCKERFILE=$(grep "^Dockerfile:" "$INFO_FILE" | cut -d: -f2- | xargs)
fi

# Fallback to standard location - extract project name from image
# If IMAGE_NAME is ds01-1001/my-project, PROJECT_NAME is my-project
PROJECT_NAME="${IMAGE_NAME##*/}"
if [ -z "$DOCKERFILE" ] || [ ! -f "$DOCKERFILE" ]; then
    DOCKERFILE="$DOCKERFILES_DIR/${PROJECT_NAME}.Dockerfile"
fi

# Check if Dockerfile exists
if [ ! -f "$DOCKERFILE" ]; then
    echo -e "${RED}âœ— Dockerfile not found${NC}"
    echo "Expected location: $DOCKERFILE"
    echo ""
    read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
    read -p "Enter path to Dockerfile: " CUSTOM_PATH </dev/tty
    if [ -f "$CUSTOM_PATH" ]; then
        DOCKERFILE="$CUSTOM_PATH"
    else
        echo -e "${RED}âœ— File not found: $CUSTOM_PATH${NC}"
        exit 1
    fi
fi

echo ""
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BOLD}Updating Dockerfile for Image: ${CYAN}$IMAGE_NAME${NC}"
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo -e "Dockerfile: ${BLUE}$DOCKERFILE${NC}"
echo ""

# Show current image info
CURRENT_SIZE=$(docker images --format "{{.Size}}" "$IMAGE_NAME" | head -1)
CURRENT_CREATED=$(docker images --format "{{.CreatedAt}}" "$IMAGE_NAME" | head -1)

echo -e "${BOLD}Current image:${NC}"
echo "  Size:    $CURRENT_SIZE"
echo "  Created: $CURRENT_CREATED"

# Handle different modes
if [ "$EDIT_FIRST" = true ]; then
    # Advanced mode: direct edit
    echo ""
    EDITOR_CMD=$(find_editor)
    if [ "$EDITOR_CMD" = "cat" ]; then
        echo -e "${RED}âœ— No text editor found${NC}"
        echo ""
        echo "Please install one of: vim, vi, nano, emacs"
        echo "Or set EDITOR environment variable to your preferred editor"
        echo ""
        exit 1
    fi
    echo -e "${YELLOW}Opening Dockerfile in $EDITOR_CMD...${NC}"
    "$EDITOR_CMD" "$DOCKERFILE"
    echo ""

elif [ -n "$QUICK_ADD_PACKAGES" ]; then
    # Quick mode: add packages from command line
    echo ""
    echo -e "${CYAN}Quick Add Mode${NC}"
    echo ""
    echo -e "${BOLD}Adding Python packages:${NC}"
    echo ""
    add_python_packages "$DOCKERFILE" $QUICK_ADD_PACKAGES
    if [ "$PACKAGES_ADDED_COUNT" -gt 0 ]; then
        echo ""
        echo -e "${GREEN}âœ“${NC} $PACKAGES_ADDED_COUNT package(s) added to Dockerfile"
    fi
    echo ""

elif [ -n "$REQUIREMENTS_FILE" ]; then
    # Requirements.txt mode: import packages from file
    echo ""
    echo -e "${CYAN}Requirements Import Mode${NC}"
    echo ""

    # Expand ~ if present
    REQUIREMENTS_FILE="${REQUIREMENTS_FILE/#\~/$HOME}"

    if ! validate_requirements_file "$REQUIREMENTS_FILE"; then
        exit 1
    fi

    req_packages=$(read_requirements_packages "$REQUIREMENTS_FILE")
    pkg_count=$(echo "$req_packages" | wc -w)
    short_path="${REQUIREMENTS_FILE/#$HOME/~}"

    echo -e "${GREEN}âœ“${NC} Will install ${BOLD}$pkg_count${NC} packages from: ${CYAN}$short_path${NC}"
    echo ""
    echo -e "${DIM}Packages: $req_packages${NC}"
    echo ""

    add_python_packages "$DOCKERFILE" $req_packages
    if [ "$PACKAGES_ADDED_COUNT" -gt 0 ]; then
        echo ""
        echo -e "${GREEN}âœ“${NC} $PACKAGES_ADDED_COUNT package(s) added to Dockerfile"
    fi
    echo ""

elif [ -n "$QUICK_ADD_SYSTEM" ]; then
    # Quick mode: add system packages from command line
    echo ""
    echo -e "${CYAN}Quick Add Mode${NC}"
    echo ""
    echo -e "${BOLD}Adding system packages:${NC}"
    echo ""
    add_system_packages "$DOCKERFILE" $QUICK_ADD_SYSTEM
    echo ""

elif [ "$GUIDED" = true ]; then
    # Guided mode: educational
    guided_mode "$DOCKERFILE"

else
    # Default: interactive mode
    interactive_mode "$DOCKERFILE"
fi

# Phase 1: Dockerfile Updated âœ“
echo ""
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${GREEN}${BOLD}âœ“ Phase 1/3: Dockerfile Updated${NC}"
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo -e "Location: ${BLUE}$DOCKERFILE${NC}"
echo ""

# Phase 2: Rebuild Image?
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BOLD}Phase 2/3: Rebuild Docker Image?${NC}"
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo "This will rebuild the image with your changes."
if [ "$NO_CACHE" = true ]; then
    echo -e "${YELLOW}âš  Building without cache (clean rebuild)${NC}"
fi
echo ""
echo -e "${DIM}Time estimate: 3-5 minutes${NC}"
echo ""
read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
read -p "Rebuild image now? [Y/n]: " REBUILD_CONFIRM </dev/tty
REBUILD_CONFIRM=${REBUILD_CONFIRM:-Y}
echo ""

if [[ ! "$REBUILD_CONFIRM" =~ ^[Yy]$ ]]; then
    echo "Rebuild skipped."
    echo ""
    echo "Your Dockerfile has been updated."
    echo "Rebuild later with:"
    echo -e "  ${GREEN}image-update $IMAGE_NAME${NC}"
    echo ""

    # Remove backup since changes were intentional
    rm -f "${DOCKERFILE}.bak"
    exit 0
fi

# Build command with user setup build args (required for DS01 user/group creation)
BUILD_CMD="docker build"
BUILD_CMD="$BUILD_CMD --build-arg DS01_USER_ID=$USER_ID"
BUILD_CMD="$BUILD_CMD --build-arg DS01_GROUP_ID=$GROUP_ID"
BUILD_CMD="$BUILD_CMD --build-arg DS01_USERNAME=$SANITIZED_USERNAME"
BUILD_CMD="$BUILD_CMD -t $IMAGE_NAME:latest -f $DOCKERFILE"
if [ "$NO_CACHE" = true ]; then
    BUILD_CMD="$BUILD_CMD --no-cache"
fi
# Use Dockerfile directory as build context
BUILD_CMD="$BUILD_CMD $(dirname "$DOCKERFILE")/"

echo ""
echo -e "${CYAN}Building image...${NC}"
echo ""

# Build
if eval "$BUILD_CMD"; then
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}${BOLD}âœ“ Phase 2/3: Docker Image Rebuilt${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""

    # Remove backup
    rm -f "${DOCKERFILE}.bak"

    # Show new image info
    NEW_SIZE=$(docker images --format "{{.Size}}" "$IMAGE_NAME" | head -1)
    NEW_CREATED=$(docker images --format "{{.CreatedAt}}" "$IMAGE_NAME" | head -1)

    echo -e "${BOLD}Updated image:${NC}"
    echo "  Size:    $NEW_SIZE"
    echo "  Created: $NEW_CREATED"
    echo ""

    # Show what changed in the Dockerfile
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Updated Dockerfile Packages${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""

    # AIME base image (from FROM line)
    base_image=$(grep "^FROM " "$DOCKERFILE" | head -1 | sed 's/FROM //')
    if [ -n "$base_image" ]; then
        echo -e "  ${BOLD}AIME base image:${NC} ${GREEN}$base_image${NC}"
    fi

    # System packages
    sys_pkgs=$(parse_system_packages "$DOCKERFILE" | tr '\n' ' ')
    if [ -n "$sys_pkgs" ]; then
        echo -e "  ${BOLD}System:${NC} $sys_pkgs"
    else
        echo -e "  ${BOLD}System:${NC} ${DIM}(none)${NC}"
    fi

    # Parse categorized Python packages
    core_pkgs=""
    usecase_pkgs=""
    custom_pkgs=""

    while IFS=: read -r category pkg; do
        case "$category" in
            core) core_pkgs="$core_pkgs $pkg" ;;
            usecase) usecase_pkgs="$usecase_pkgs $pkg" ;;
            custom) custom_pkgs="$custom_pkgs $pkg" ;;
        esac
    done < <(parse_python_packages_by_category "$DOCKERFILE")

    # Display Python packages by category
    if [ -n "$core_pkgs" ]; then
        echo -e "  ${BOLD}Core Python:${NC}$core_pkgs"
    else
        echo -e "  ${BOLD}Core Python:${NC} ${DIM}(none)${NC}"
    fi

    if [ -n "$usecase_pkgs" ]; then
        echo -e "  ${BOLD}Pre-installed for use case:${NC}$usecase_pkgs"
    else
        echo -e "  ${BOLD}Pre-installed for use case:${NC} ${DIM}(none)${NC}"
    fi

    if [ -n "$custom_pkgs" ]; then
        echo -e "  ${BOLD}Custom-installed:${NC}$custom_pkgs"
    else
        echo -e "  ${BOLD}Custom-installed:${NC} ${DIM}(none)${NC}"
    fi
    echo ""

    # Update metadata
    if [ -f "$INFO_FILE" ]; then
        sed -i.bak "s/^Created:.*/Created: $(date)/" "$INFO_FILE"
        rm -f "${INFO_FILE}.bak"
    fi

    # Check for containers using this image
    # Extract project name from image (ds01-1001/my-project â†’ my-project)
    CONTAINER_BASE_NAME="${IMAGE_NAME##*/}"
    CONTAINER_BASE_NAME="${CONTAINER_BASE_NAME%-image}"  # Remove -image suffix if present
    FULL_CONTAINER_NAME="$CONTAINER_BASE_NAME._.$(id -u)"

    # Phase 3: Recreate Container?
    if docker ps -a --format "{{.Names}}" | grep -q "^${FULL_CONTAINER_NAME}$"; then
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BOLD}Phase 3/3: Recreate Container?${NC}"
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo "Your image has been updated, but your container is still"
        echo "using the old image. To use the new packages, you need to"
        echo "recreate and deploy the container based on the updated image."
        echo ""
        echo -e "${YELLOW}âš ${NC} This will:"
        echo "  â€¢ Stop the current container"
        echo "  â€¢ Remove the old container"
        echo "  â€¢ Create a new container from the updated image"
        echo "  â€¢ Your workspace files will be preserved"
        echo ""
        read -r -t 0.1 -n 10000 discard </dev/tty 2>/dev/null || true
        read -p "Recreate container now? [Y/n]: " RECREATE_CONFIRM </dev/tty
        RECREATE_CONFIRM=${RECREATE_CONFIRM:-Y}

        if [[ "$RECREATE_CONFIRM" =~ ^[Yy]$ ]]; then
            echo ""
            echo -e "${CYAN}Recreating container...${NC}"
            echo ""

            # Stop container if running
            if docker ps --format "{{.Names}}" | grep -q "^${FULL_CONTAINER_NAME}$"; then
                echo -e "  ${DIM}Stopping container...${NC}"
                docker stop "$FULL_CONTAINER_NAME" >/dev/null 2>&1
            fi

            # Remove old container
            echo -e "  ${DIM}Removing old container...${NC}"
            docker rm "$FULL_CONTAINER_NAME" >/dev/null 2>&1

            # Deploy new container
            echo -e "  ${DIM}Deploying new container...${NC}"
            echo ""
            if command -v container-deploy &>/dev/null; then
                container-deploy "$CONTAINER_BASE_NAME" --background
                echo ""
                echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                echo -e "${GREEN}${BOLD}âœ“ Phase 3/3: Container Deployed${NC}"
                echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                echo ""
                echo -e "${BOLD}All Done!${NC}"
                echo ""
                echo -e "Your container is running with the updated image."
            else
                echo -e "${RED}âœ— container-deploy command not found${NC}"
                echo "Please deploy the container manually."
            fi
        else
            echo ""
            echo "Skipped container recreation."
            echo ""
            echo "To redeploy manually later:"
            echo ""
            echo -e "  ${BOLD}1.${NC} Retire the old container:"
            echo -e "     ${GREEN}container-retire $CONTAINER_BASE_NAME${NC}"
            echo ""
            echo -e "  ${BOLD}2.${NC} Deploy new container from updated image:"
            echo -e "     ${GREEN}container-deploy $CONTAINER_BASE_NAME${NC}"
        fi
    else
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BOLD}Next Steps: Deploy Container${NC}"
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo "Your image is ready! Deploy a container to use it:"
        echo ""
        echo -e "  ${GREEN}container-deploy $CONTAINER_BASE_NAME${NC}"
    fi
    echo ""

else
    echo ""
    echo -e "${RED}âœ— Build failed${NC}"
    echo ""
    echo "Troubleshooting:"
    echo -e "  1. Check Dockerfile syntax: ${BLUE}cat $DOCKERFILE${NC}"
    echo -e "  2. View backup: ${BLUE}cat ${DOCKERFILE}.bak${NC}"
    echo -e "  3. Restore backup: ${GREEN}mv ${DOCKERFILE}.bak $DOCKERFILE${NC}"
    echo -e "  4. Try again: ${GREEN}image-update $IMAGE_NAME${NC}"
    echo ""
    exit 1
fi

echo ""
