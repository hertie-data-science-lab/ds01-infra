#!/bin/bash
# Docker Image Updater with Interactive Package Management
# Supports adding/removing packages without manual Dockerfile editing

set -e

BLUE='\033[94m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

USERNAME=$(whoami)
DOCKERFILES_DIR="$HOME/dockerfiles"

normalize_package_name() {
    # Normalize package name: lowercase, strip version specifiers
    local pkg="$1"
    # Remove version specifiers (==, >=, <=, ~=, etc.)
    pkg=$(echo "$pkg" | sed 's/[=<>~!].*//')
    # Convert to lowercase
    echo "$pkg" | tr '[:upper:]' '[:lower:]'
}

check_duplicate_packages() {
    # Check if any input packages are already in existing packages
    # Args: $1 = new packages (space-separated), $2... = existing package lists
    local new_packages="$1"
    shift
    local existing_packages="$*"

    # Build array of existing packages (normalized)
    local existing_array=()
    for pkg in $existing_packages; do
        local normalized=$(normalize_package_name "$pkg")
        existing_array+=("$normalized")
    done

    # Check each new package
    local duplicates=()
    for new_pkg in $new_packages; do
        local new_normalized=$(normalize_package_name "$new_pkg")
        for existing in "${existing_array[@]}"; do
            if [ "$new_normalized" = "$existing" ]; then
                duplicates+=("$new_pkg")
                break
            fi
        done
    done

    # Return duplicates (space-separated)
    if [ ${#duplicates[@]} -gt 0 ]; then
        echo "${duplicates[@]}"
        return 1
    fi
    return 0
}

# Find available text editor
find_editor() {
    # Try these editors in order
    for editor in "${EDITOR:-}" vim vi nano emacs; do
        if [ -n "$editor" ] && command -v "$editor" &> /dev/null; then
            echo "$editor"
            return 0
        fi
    done
    # Fallback to cat for viewing if no editor found
    echo "cat"
    return 1
}

# Custom image selection function
select_image_interactive() {
    while true; do
        # All display output goes to stderr so it's visible to user
        echo "" >&2
        echo -e "${CYAN}â”â”â” Your Docker Images â”â”â”${NC}" >&2
        echo "" >&2

        # Get list of user's images - filter by DS01 naming pattern
        local images=()
        local user_id=$(id -u)
        mapfile -t images < <(docker images --format "{{.Repository}}" 2>/dev/null | grep "^ds01-$user_id/" | grep -v "REPOSITORY")

        # Show only DS01 images in table format
        if [ ${#images[@]} -gt 0 ]; then
            # Build filter expression for docker images command
            local filter_expr=""
            for img in "${images[@]}"; do
                if [ -n "$filter_expr" ]; then
                    filter_expr="$filter_expr|"
                fi
                filter_expr="$filter_expr$img"
            done
            docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.CreatedSince}}" | \
                head -1 >&2  # Show header
            docker images --format "{{.Repository}}\t{{.Tag}}\t{{.CreatedSince}}" | \
                grep -E "^($filter_expr)" >&2
        fi

        echo "" >&2

        # Remove empty entries
        local filtered_images=()
        for img in "${images[@]}"; do
            if [ -n "$img" ]; then
                filtered_images+=("$img")
            fi
        done
        images=("${filtered_images[@]}")

        local count=${#images[@]}

        if [ "$count" -eq 0 ]; then
            echo -e "${RED}No images found${NC}" >&2
            echo "" >&2
            echo "Run ${GREEN}image-create${NC} to create your first image" >&2
            return 1
        fi

        echo -e "${BOLD}Total: $count image(s)${NC}" >&2
        echo "" >&2
        echo -e "${CYAN}Select an image to update:${NC}" >&2
        echo "" >&2

        # Display numbered list
        local i=1
        for img in "${images[@]}"; do
            echo " $i) $img" >&2
            ((i++))
        done
        echo " $i) Exit" >&2
        echo "" >&2

        read -p "Select number (or 'q' to quit): " selection </dev/tty

        # Handle exit
        if [ "$selection" = "q" ] || [ "$selection" = "$i" ]; then
            return 1
        fi

        # Validate selection
        if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -ge "$i" ]; then
            echo -e "${RED}Invalid selection. Please try again.${NC}" >&2
            sleep 1
            continue
        fi

        # Get selected image - THIS goes to stdout for capture
        local selected_image="${images[$((selection-1))]}"
        echo "$selected_image"
        return 0
    done
}

usage() {
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Docker Image Updater${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${CYAN}Usage:${NC}"
    echo "  image-update [image-name] [options]"
    echo "  image-update                                 # Prompts to select image (if none specified)"
    echo "  image-update <image-name>                    # Interactive mode (default)"
    echo ""
    echo -e "${CYAN}Options:${NC}"
    echo "  --add \"pkg1 pkg2\"    Add packages directly (quick mode)"
    echo "  --add-system \"pkg1\"  Add system packages directly"
    echo "  --edit               Edit Dockerfile manually (advanced)"
    echo "  --guided             Show detailed explanations (educational)"
    echo "  --no-cache           Build without using cache (clean rebuild)"
    echo "  -h, --help           Show this help message"
    echo ""
    echo -e "${CYAN}Modes:${NC}"
    echo -e "  ${BOLD}Interactive${NC} (default)  - User-friendly GUI for package management"
    echo -e "  ${BOLD}Quick${NC} (--add)          - Add packages from command line"
    echo -e "  ${BOLD}Advanced${NC} (--edit)      - Direct Dockerfile editing"
    echo -e "  ${BOLD}Guided${NC} (--guided)      - Educational mode with explanations"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo -e "  ${DIM}# Interactive mode (shows current packages, prompts for changes)${NC}"
    echo "  image-update my-project"
    echo ""
    echo -e "  ${DIM}# Quick add packages without interaction${NC}"
    echo "  image-update my-project --add \"wandb optuna pytorch-lightning\""
    echo ""
    echo -e "  ${DIM}# Add system packages${NC}"
    echo "  image-update my-project --add-system \"tmux htop\""
    echo ""
    echo -e "  ${DIM}# Edit Dockerfile directly (power users)${NC}"
    echo "  image-update my-project --edit"
    echo ""
    echo -e "  ${DIM}# Guided mode for beginners${NC}"
    echo "  image-update my-project --guided"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ After updating:${NC}"
    echo "   Redeploy containers to use the new image:"
    echo -e "   ${GREEN}container-retire my-project${NC}  ${DIM}# Stop + remove${NC}"
    echo -e "   ${GREEN}container-deploy my-project${NC}  ${DIM}# Create + start${NC}"
    echo ""
}

# Parse Dockerfile to extract Python packages (simple list)
parse_python_packages() {
    local dockerfile="$1"

    # Extract all lines between "RUN pip install" and the next empty line or next RUN command
    # Handles both single-line and multi-line pip install blocks
    awk '
    /^RUN pip install/ {
        # Extract packages from the same line (single-line format)
        line = $0
        sub(/^RUN pip install[[:space:]]+(--no-cache-dir[[:space:]]+)?/, "", line)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
        if (line != "") {
            # Single-line format: print packages from this line
            split(line, pkgs, /[[:space:]]+/)
            for (i in pkgs) {
                if (pkgs[i] != "" && pkgs[i] !~ /^--/) {
                    print pkgs[i]
                }
            }
        }
        in_pip=1
        next
    }
    in_pip {
        if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
            in_pip=0
        } else {
            # Multi-line format: extract packages from continuation lines
            gsub(/^[[:space:]]+/, "")
            gsub(/[[:space:]]*\\[[:space:]]*$/, "")
            if ($0 != "" && $0 !~ /^--/) {
                print $0
            }
        }
    }
    ' "$dockerfile" | sort -u
}

# Parse Dockerfile to extract categorized Python packages
parse_python_packages_by_category() {
    local dockerfile="$1"

    # Extract packages organized by their comment sections (matching image-create structure)
    awk '
    /^# Jupyter & Interactive/ || /^# Jupyter.*Interactive/ { category="jupyter"; next }
    /^# Core Data Science/ { category="datascience"; next }
    /^# Core Python packages/ { category="core"; next }
    /^# Use case specific packages/ { category="usecase"; next }
    /^# Custom additional packages/ || /^# Additional.*packages/ { category="custom"; next }
    /^RUN pip install/ {
        in_pip=1
        # Extract packages from the same line (single-line format)
        line = $0
        sub(/^RUN pip install[[:space:]]+(--no-cache-dir[[:space:]]+)?/, "", line)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
        if (line != "") {
            split(line, pkgs, /[[:space:]]+/)
            for (i in pkgs) {
                if (pkgs[i] != "" && pkgs[i] !~ /^--/ && category != "") {
                    print category ":" pkgs[i]
                }
            }
        }
        next
    }
    in_pip {
        if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
            in_pip=0
            category=""
        } else {
            gsub(/^[[:space:]]+/, "")
            gsub(/[[:space:]]*\\[[:space:]]*$/, "")
            if ($0 != "" && $0 !~ /^--/ && category != "") {
                print category ":" $0
            }
        }
    }
    ' "$dockerfile"
}

# Parse Dockerfile to extract system packages
parse_system_packages() {
    local dockerfile="$1"

    # Extract system packages from apt-get install blocks (handles multi-line)
    awk '
    /apt-get install/ {
        in_apt=1
        # Extract packages from the same line if any
        line = $0
        sub(/.*apt-get install[[:space:]]+(-y[[:space:]]+)?(--no-install-recommends[[:space:]]+)?/, "", line)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
        gsub(/&&.*/, "", line)
        if (line != "") {
            split(line, pkgs, /[[:space:]]+/)
            for (i in pkgs) {
                if (pkgs[i] != "" && pkgs[i] !~ /^-/ && pkgs[i] != "apt-get" && pkgs[i] != "update") {
                    print pkgs[i]
                }
            }
        }
        next
    }
    in_apt {
        if (/&&/ || /^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
            in_apt=0
        } else {
            # Extract packages from continuation lines
            line = $0
            gsub(/^[[:space:]]+/, "", line)
            gsub(/[[:space:]]*\\[[:space:]]*$/, "", line)
            gsub(/&&.*/, "", line)
            if (line != "" && line !~ /^-/ && line != "apt-get" && line != "update" && line != "rm") {
                print line
            }
        }
    }
    ' "$dockerfile" | sort -u
}

# Add Python packages to Dockerfile
# Returns: 0 if packages added, 1 if error, sets PACKAGES_ADDED_COUNT
add_python_packages() {
    local dockerfile="$1"
    shift
    local packages=("$@")
    PACKAGES_ADDED_COUNT=0

    # Find "# Custom additional packages" section
    local custom_line=$(grep -n "^# Custom additional packages" "$dockerfile" | cut -d: -f1)

    if [ -z "$custom_line" ]; then
        echo -e "${RED}âœ— Could not find '# Custom additional packages' section in Dockerfile${NC}"
        return 1
    fi

    # Create backup
    cp "$dockerfile" "${dockerfile}.bak"

    # Check if there's already a RUN pip install after the custom comment
    local next_line=$((custom_line + 1))
    local next_line_content=$(sed -n "${next_line}p" "$dockerfile")

    local last_pip_line=""
    local is_multiline=false

    if [[ "$next_line_content" =~ ^RUN\ pip\ install ]]; then
        # There's already a RUN pip install in the custom section
        last_pip_line=$next_line
        if [[ "$next_line_content" =~ \\[[:space:]]*$ ]]; then
            is_multiline=true
        fi
    else
        # No RUN pip install yet - insert one after the comment
        sed -i "${custom_line}a\\RUN pip install --no-cache-dir \\\\" "$dockerfile"
        last_pip_line=$((custom_line + 1))
        is_multiline=true
    fi

    # Add packages
    for pkg in "${packages[@]}"; do
        # Extract base package name (remove version specifiers like ==, >=, etc.)
        local pkg_base=$(echo "$pkg" | sed 's/[=><!].*//')

        # Check if package already exists by parsing the dockerfile properly
        if parse_python_packages "$dockerfile" | grep -qxi "$pkg_base"; then
            echo -e "${YELLOW}  âš  $pkg_base already in Dockerfile, skipping${NC}"
            echo ""
            continue
        fi

        if [ "$is_multiline" = true ]; then
            # Multi-line format: Find the last package line (line before empty line or next section)
            # and add backslash to it if it doesn't have one, then insert new package without backslash
            local next_empty_line=$(awk -v start="$last_pip_line" 'NR > start && /^$/ {print NR; exit}' "$dockerfile")
            local next_run_line=$(awk -v start="$last_pip_line" 'NR > start && /^RUN/ {print NR; exit}' "$dockerfile")
            local next_comment_line=$(awk -v start="$last_pip_line" 'NR > start && /^#/ {print NR; exit}' "$dockerfile")

            # Find which comes first (the end of this pip block)
            local end_line=""
            if [ -n "$next_empty_line" ]; then
                end_line=$next_empty_line
            fi
            if [ -n "$next_run_line" ] && { [ -z "$end_line" ] || [ "$next_run_line" -lt "$end_line" ]; }; then
                end_line=$next_run_line
            fi
            if [ -n "$next_comment_line" ] && { [ -z "$end_line" ] || [ "$next_comment_line" -lt "$end_line" ]; }; then
                end_line=$next_comment_line
            fi

            if [ -n "$end_line" ]; then
                local insert_line=$((end_line - 1))
                # Check if the line before end has a backslash
                if ! sed -n "${insert_line}p" "$dockerfile" | grep -q '\\$'; then
                    # Add backslash to previous last line
                    sed -i "${insert_line}s/$/ \\\\/" "$dockerfile"
                fi
                # Insert new package without backslash after the previous last line
                sed -i "${insert_line}a\\    $pkg" "$dockerfile"
            else
                # No end found, just append with backslash
                sed -i "${last_pip_line}a\\    $pkg \\\\" "$dockerfile"
            fi
        else
            # Single-line format: convert to multi-line and add package
            # Replace the RUN line to add backslash, then add package on next line without backslash
            sed -i "${last_pip_line}s/$/ \\\\/" "$dockerfile"
            sed -i "${last_pip_line}a\\    $pkg" "$dockerfile"
            is_multiline=true  # Now it's multi-line for subsequent packages
        fi

        echo -e "${GREEN}  âœ“${NC} Added: $pkg"
        PACKAGES_ADDED_COUNT=$((PACKAGES_ADDED_COUNT + 1))
    done

    # Show summary after adding all packages
    if [ "$PACKAGES_ADDED_COUNT" -gt 0 ]; then
        echo ""
        echo -e "${GREEN}âœ“${NC} Added $PACKAGES_ADDED_COUNT package(s) to Dockerfile"
        echo ""
        echo -e "Updated Dockerfile: ${BLUE}$dockerfile${NC}"
        echo ""
    fi

    return 0
}

# Add system packages to Dockerfile
add_system_packages() {
    local dockerfile="$1"
    shift
    local packages=("$@")

    # Find the apt-get install line
    local apt_line=$(grep -n "apt-get install" "$dockerfile" | head -1 | cut -d: -f1)

    if [ -z "$apt_line" ]; then
        echo -e "${RED}âœ— Could not find apt-get install section in Dockerfile${NC}"
        return 1
    fi

    # Create backup
    cp "$dockerfile" "${dockerfile}.bak"

    # Add packages to apt-get install line
    for pkg in "${packages[@]}"; do
        # Check if package already exists
        if grep -q "$pkg" "$dockerfile"; then
            echo -e "${YELLOW}  âš  $pkg already in Dockerfile, skipping${NC}"
            continue
        fi

        # Insert package in apt-get install line
        sed -i "${apt_line}s/$/ \\\\\n    $pkg/" "$dockerfile"
        echo -e "${GREEN}  âœ“${NC} Added: $pkg"
    done

    return 0
}

# Remove packages from Dockerfile
remove_packages() {
    local dockerfile="$1"
    shift
    local packages=("$@")

    cp "$dockerfile" "${dockerfile}.bak"

    for pkg in "${packages[@]}"; do
        # Extract base package name (remove version specifiers)
        local pkg_base=$(echo "$pkg" | sed 's/[=><!~].*//')

        # Only remove lines that are part of pip install blocks and match the package as a whole word
        # This prevents accidentally removing lines like "torchvision" when trying to remove "torch"
        local removed=false

        # Find all pip install blocks and remove matching package lines
        awk -v pkg="$pkg_base" '
        BEGIN { in_pip=0 }
        /^RUN pip install/ { in_pip=1; print; next }
        in_pip {
            # Check if end of pip block
            if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/) {
                in_pip=0
                print
                next
            }
            # Extract package name from line (remove leading spaces and trailing backslash)
            line_pkg = $0
            gsub(/^[[:space:]]+/, "", line_pkg)
            gsub(/[[:space:]]*\\[[:space:]]*$/, "", line_pkg)
            gsub(/[=><!~].*/, "", line_pkg)  # Remove version specifiers

            # Only skip this line if it matches the package exactly
            if (line_pkg == pkg) {
                next  # Skip this line (effectively removing it)
            }
            print
        }
        !in_pip { print }
        ' "$dockerfile" > "${dockerfile}.tmp" && mv "${dockerfile}.tmp" "$dockerfile"

        if ! diff -q "${dockerfile}.bak" "$dockerfile" > /dev/null 2>&1; then
            echo -e "${GREEN}  âœ“${NC} Removed: $pkg"
            removed=true
        else
            echo -e "${YELLOW}  âš ${NC} Package not found: $pkg"
        fi
    done

    # Clean up empty RUN pip install blocks that have no packages
    # This prevents Docker build errors from empty pip install commands
    awk '
    BEGIN {
        in_pip=0
        pip_start_line=0
        pip_has_packages=0
        buffer=""
        buffer_count=0
    }
    /^RUN pip install/ {
        # Flush previous pip block if needed
        if (in_pip && pip_has_packages) {
            print buffer
        }
        # Start new pip block
        in_pip=1
        pip_start_line=NR
        pip_has_packages=0
        buffer=$0 "\n"
        buffer_count=1
        next
    }
    in_pip {
        # Check if end of pip block
        if (/^$/ || /^RUN/ || /^#/ || /^ENV/ || /^WORKDIR/ || /^CMD/ || /^LABEL/ || /^FROM/) {
            # End of pip block - print buffer only if it has packages
            if (pip_has_packages) {
                print buffer $0
            } else {
                print "# [Removed empty pip install block]"
                print $0
            }
            in_pip=0
            buffer=""
            buffer_count=0
            next
        }

        # Inside pip block - check if line has a package
        line_stripped = $0
        gsub(/^[[:space:]]+/, "", line_stripped)
        gsub(/[[:space:]]*\\[[:space:]]*$/, "", line_stripped)

        if (line_stripped != "" && line_stripped !~ /^--/) {
            pip_has_packages=1
        }

        buffer = buffer $0 "\n"
        buffer_count++
        next
    }
    !in_pip {
        print
    }
    END {
        # Handle last pip block if file ends in one
        if (in_pip && pip_has_packages) {
            printf "%s", buffer
        }
    }
    ' "$dockerfile" > "${dockerfile}.tmp" && mv "${dockerfile}.tmp" "$dockerfile"

    # Check if any empty blocks were removed
    if grep -q "# \[Removed empty pip install block\]" "$dockerfile"; then
        echo -e "${YELLOW}  â„¹${NC} Removed empty pip install block (prevents build errors)"
        # Clean up the marker comments
        sed -i '/# \[Removed empty pip install block\]/d' "$dockerfile"
    fi

    return 0
}

# Interactive mode
interactive_mode() {
    local dockerfile="$1"

    while true; do

        # Show current packages categorized
        echo ""
        echo -e "${BOLD}Current Configuration:${NC}"
        echo ""

        # AIME base image (from FROM line)
        local base_image=$(grep "^FROM " "$dockerfile" | head -1 | sed 's/FROM //')
        if [ -n "$base_image" ]; then
            echo -e "  ${BOLD}â€¢ AIME Base Image:${NC} ${GREEN}$base_image${NC}"

            # Show key packages from AIME base (if it's an AIME image)
            if [[ "$base_image" =~ aimehub/ ]]; then
                echo -e "    â€¢ ${DIM}Pre-installed: torch, numpy, pillow, tqdm, conda, ipython, psutil${NC}"
                echo -e "    â€¢ ${DIM}(Use 'docker run --rm $base_image pip list' to see all)${NC}"
            fi
        fi

        # System packages
        local sys_pkgs=$(parse_system_packages "$dockerfile" | tr '\n' ' ')
        if [ -n "$sys_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}System:${NC} $sys_pkgs"
        else
            echo -e "  â€¢ ${BOLD}System:${NC} ${DIM}(none)${NC}"
        fi

        # Parse categorized Python packages (matching image-create structure)
        local jupyter_pkgs=""
        local datascience_pkgs=""
        local core_pkgs=""  # Legacy category for old Dockerfiles
        local usecase_pkgs=""
        local custom_pkgs=""

        while IFS=: read -r category pkg; do
            case "$category" in
                jupyter) jupyter_pkgs="$jupyter_pkgs $pkg" ;;
                datascience) datascience_pkgs="$datascience_pkgs $pkg" ;;
                core) core_pkgs="$core_pkgs $pkg" ;;  # Legacy
                usecase) usecase_pkgs="$usecase_pkgs $pkg" ;;
                custom) custom_pkgs="$custom_pkgs $pkg" ;;
            esac
        done < <(parse_python_packages_by_category "$dockerfile")

        # Display Python packages by category (new structure from image-create)
        if [ -n "$jupyter_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Jupyter & Interactive:${NC}$jupyter_pkgs"
        elif [ -n "$core_pkgs" ]; then
            # Legacy: old Dockerfiles had everything as "core"
            echo -e "  â€¢ ${BOLD}Core Python:${NC}$core_pkgs ${DIM}(legacy format)${NC}"
        else
            echo -e "  â€¢ ${BOLD}Jupyter & Interactive:${NC} ${DIM}(none)${NC}"
        fi

        if [ -n "$datascience_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Data Science:${NC}$datascience_pkgs"
        else
            echo -e "  â€¢ ${BOLD}Data Science:${NC} ${DIM}(none)${NC}"
        fi

        if [ -n "$usecase_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Use Case Specific:${NC}$usecase_pkgs"
        else
            echo -e "  â€¢ ${BOLD}Use Case Specific:${NC} ${DIM}(none)${NC}"
        fi

        if [ -n "$custom_pkgs" ]; then
            echo -e "  â€¢ ${BOLD}Custom-installed:${NC}$custom_pkgs"
        else
            echo -e "  â€¢ ${BOLD}Custom-installed:${NC} ${DIM}(none)${NC}"
        fi

        echo ""

        echo -e "${BOLD}What would you like to do?${NC}"
        echo ""
        echo -e "  ${BOLD}1)${NC} Add Python packages (pip)"
        echo -e "  ${BOLD}2)${NC} Add system packages (apt)"
        echo -e "  ${BOLD}3)${NC} Remove packages"
        echo -e "  ${BOLD}4)${NC} Edit Dockerfile directly ${DIM}(advanced)${NC}"
        echo -e "  ${BOLD}5)${NC} Continue to rebuild ${BOLD}${YELLOW}(necessary to apply changes!)${NC}"
        echo -e "  ${BOLD}6)${NC} Cancel"
        echo ""
        read -p "Choice [1-6]: " CHOICE </dev/tty

        case $CHOICE in
            1)
                # Loop until no duplicates
                while true; do
                    echo ""
                    echo -e "${BOLD}Add Python Packages${NC}"
                    echo ""
                    echo "Enter package names (space-separated):"
                    echo -e "${DIM}Examples: wandb optuna pytorch-lightning pandas==1.5.3 transformers>=4.30.0${NC}"
                    echo ""
                    read -p "> " NEW_PACKAGES </dev/tty

                    if [ -z "$NEW_PACKAGES" ]; then
                        echo -e "${YELLOW}No packages entered${NC}"
                        break
                    fi

                    # Get all currently installed packages
                    local aime_base="numpy pillow tqdm conda ipython psutil torch torchvision torchaudio"
                    local all_current=""
                    if [ -n "$jupyter_pkgs" ]; then
                        all_current="$all_current $jupyter_pkgs"
                    fi
                    if [ -n "$datascience_pkgs" ]; then
                        all_current="$all_current $datascience_pkgs"
                    fi
                    if [ -n "$core_pkgs" ]; then
                        all_current="$all_current $core_pkgs"
                    fi
                    if [ -n "$usecase_pkgs" ]; then
                        all_current="$all_current $usecase_pkgs"
                    fi
                    if [ -n "$custom_pkgs" ]; then
                        all_current="$all_current $custom_pkgs"
                    fi

                    # Check for duplicates
                    local duplicates=$(check_duplicate_packages "$NEW_PACKAGES" "$aime_base" "$all_current")

                    if [ $? -eq 1 ]; then
                        echo ""
                        echo -e "${YELLOW}âš   Warning: These packages are already installed:${NC}"
                        echo -e "   ${YELLOW}$duplicates${NC}"
                        echo ""
                        echo "Please enter different packages (or press Enter to cancel):"
                    else
                        # No duplicates, proceed with adding
                        echo ""
                        echo -e "${CYAN}Adding packages...${NC}"
                        echo ""
                        add_python_packages "$dockerfile" $NEW_PACKAGES
                        if [ "$PACKAGES_ADDED_COUNT" -gt 0 ]; then
                            echo -e "${YELLOW}ğŸ’¡ To apply changes, you'll need to rebuild the image based on the updated Dockerfile.${NC}"
                            echo ""
                            read -p "Rebuild now? [Y/n]: " REBUILD_NOW </dev/tty
                            REBUILD_NOW=${REBUILD_NOW:-Y}
                            if [[ "$REBUILD_NOW" =~ ^[Yy]$ ]]; then
                                echo ""
                                return 0  # Exit interactive mode to proceed to rebuild
                            fi
                        fi
                        break
                    fi
                done
                ;;

            2)
                echo ""
                echo -e "${BOLD}Add System Packages${NC}"
                echo ""
                echo "Enter system package names (space-separated):"
                echo -e "${DIM}Examples: tmux htop tree${NC}"
                echo ""
                read -p "> " NEW_SYS_PACKAGES </dev/tty

                if [ -n "$NEW_SYS_PACKAGES" ]; then
                    echo ""
                    echo -e "${CYAN}Adding system packages...${NC}"
                    echo ""
                    add_system_packages "$dockerfile" $NEW_SYS_PACKAGES
                    echo ""
                    echo -e "${GREEN}âœ“${NC} System packages added to Dockerfile"
                    echo ""
                    echo -e "${YELLOW}ğŸ’¡ To apply changes, you'll need to rebuild the image based on the updated Dockerfile.${NC}"
                    echo ""
                    read -p "Rebuild now? [Y/n]: " REBUILD_NOW </dev/tty
                    REBUILD_NOW=${REBUILD_NOW:-Y}
                    if [[ "$REBUILD_NOW" =~ ^[Yy]$ ]]; then
                        echo ""
                        return 0  # Exit interactive mode to proceed to rebuild
                    fi
                else
                    echo -e "${YELLOW}No packages entered${NC}"
                fi
                ;;

            3)
                echo ""
                echo -e "${BOLD}Remove Packages${NC}"
                echo ""
                echo "Enter package names to remove (space-separated):"
                echo ""
                read -p "> " REMOVE_PACKAGES </dev/tty

                if [ -n "$REMOVE_PACKAGES" ]; then
                    echo ""
                    echo -e "${CYAN}Removing packages...${NC}"
                    echo ""
                    remove_packages "$dockerfile" $REMOVE_PACKAGES
                    echo ""
                    echo -e "${GREEN}âœ“${NC} Packages removed from Dockerfile"
                    echo ""
                    echo -e "${YELLOW}ğŸ’¡ To apply changes, you'll need to rebuild the image based on the updated Dockerfile.${NC}"
                    echo ""
                    read -p "Rebuild now? [Y/n]: " REBUILD_NOW </dev/tty
                    REBUILD_NOW=${REBUILD_NOW:-Y}
                    if [[ "$REBUILD_NOW" =~ ^[Yy]$ ]]; then
                        echo ""
                        return 0  # Exit interactive mode to proceed to rebuild
                    fi
                else
                    echo -e "${YELLOW}No packages entered${NC}"
                    echo ""
                fi
                ;;

            4)
                echo ""
                EDITOR_CMD=$(find_editor)
                if [ "$EDITOR_CMD" = "cat" ]; then
                    echo -e "${RED}âœ— No text editor found${NC}"
                    echo ""
                    echo "Please install one of: vim, vi, nano, emacs"
                    echo "Or set EDITOR environment variable to your preferred editor"
                    echo ""
                    echo "For now, displaying Dockerfile content:"
                    echo ""
                    cat "$dockerfile"
                    echo ""
                    read -p "Press Enter to continue..." </dev/tty
                else
                    echo -e "${YELLOW}Opening Dockerfile in $EDITOR_CMD...${NC}"
                    echo ""
                    "$EDITOR_CMD" "$dockerfile"
                    echo ""
                    echo -e "${GREEN}âœ“${NC} Dockerfile edited"
                fi
                ;;

            5)
                echo ""
                return 0
                ;;

            6)
                echo ""
                echo "Cancelled."
                exit 0
                ;;

            *)
                echo -e "${RED}Invalid choice${NC}"
                ;;
        esac
    done
}

# Guided mode with educational content
guided_mode() {
    local dockerfile="$1"

    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Docker Image Updates - Guided Mode${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${BOLD}Understanding Docker Images${NC}"
    echo ""
    echo -e "A Docker image is like a ${CYAN}blueprint${NC} for your computing environment."
    echo "It defines what software, packages, and tools are installed."
    echo ""
    echo -e "${BOLD}Why Can't I Just 'pip install' in My Container?${NC}"
    echo ""
    echo -e "${YELLOW}You can, BUT:${NC}"
    echo ""
    echo -e "  ${CYAN}Temporary Install${NC} (pip install in container):"
    echo "    âœ“ Fast for testing"
    echo "    âœ“ No rebuild needed"
    echo "    âœ— Lost when container is removed"
    echo "    âœ— Not reproducible"
    echo "    âœ— Can't share with colleagues"
    echo ""
    echo -e "  ${GREEN}Permanent Install${NC} (update image):"
    echo "    âœ“ Persists across container recreations"
    echo "    âœ“ Reproducible setup"
    echo "    âœ“ Can share with team"
    echo "    âœ“ Documented in Dockerfile"
    echo "    âœ— Takes 3-5 minutes to rebuild"
    echo ""
    echo -e "${BOLD}Best Practice Workflow:${NC}"
    echo ""
    echo -e "  1. ${CYAN}Test${NC} new packages: pip install in container"
    echo -e "  2. ${CYAN}Confirm${NC} they work: run your code"
    echo -e "  3. ${CYAN}Make permanent${NC}: image-update (this command)"
    echo -e "  4. ${CYAN}Recreate/deploy${NC} container with updated image"
    echo ""
    echo -e "${BOLD}What This Command Does:${NC}"
    echo ""
    echo "  â€¢ Shows packages currently in your image"
    echo "  â€¢ Lets you add/remove packages easily"
    echo "  â€¢ Updates the Dockerfile automatically"
    echo "  â€¢ Rebuilds the image with your changes"
    echo "  â€¢ Creates a permanent, reproducible setup"
    echo ""
    echo -e "${BOLD}Package Versions:${NC}"
    echo ""
    echo "  â€¢ ${CYAN}Without version${NC}: 'pandas' â†’ installs latest stable"
    echo "  â€¢ ${CYAN}Exact version${NC}: 'pandas==1.5.3' â†’ installs 1.5.3"
    echo "  â€¢ ${CYAN}Minimum version${NC}: 'pandas>=2.0.0' â†’ installs latest â‰¥2.0.0"
    echo "  â€¢ ${CYAN}Compatible${NC}: 'pandas~=1.5.0' â†’ installs latest 1.5.x"
    echo ""
    read -p "Press Enter to continue..." </dev/tty
    echo ""

    # Now run interactive mode
    interactive_mode "$dockerfile"
}

# Parse arguments
IMAGE_NAME=""
EDIT_FIRST=false
NO_CACHE=false
QUICK_ADD_PACKAGES=""
QUICK_ADD_SYSTEM=""
GUIDED=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --add)
            QUICK_ADD_PACKAGES="$2"
            shift 2
            ;;
        --add-system)
            QUICK_ADD_SYSTEM="$2"
            shift 2
            ;;
        --edit)
            EDIT_FIRST=true
            shift
            ;;
        --guided)
            GUIDED=true
            shift
            ;;
        --no-cache)
            NO_CACHE=true
            shift
            ;;
        -h|--help|--info)
            usage
            exit 0
            ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}\n"
            usage
            exit 1
            ;;
        *)
            if [ -z "$IMAGE_NAME" ]; then
                IMAGE_NAME="$1"
            else
                echo -e "${RED}Multiple image names specified${NC}\n"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

# If no image name provided, prompt to select
if [ -z "$IMAGE_NAME" ]; then
    IMAGE_NAME=$(select_image_interactive)
    if [ $? -ne 0 ] || [ -z "$IMAGE_NAME" ]; then
        echo "No selection made. Exiting."
        exit 0
    fi
    echo ""
fi

# Validate image name
if [ -z "$IMAGE_NAME" ]; then
    echo -e "${RED}Error: Image name is required${NC}\n"
    usage
    exit 1
fi

# Check if image exists
USER_ID=$(id -u)
GROUP_ID=$(id -g)
# Source username utilities and sanitize (handles @, ., and 32-char limit)
source "/opt/ds01-infra/scripts/lib/username-utils.sh"
SANITIZED_USERNAME=$(sanitize_username_for_slice "$USERNAME")

if docker images --format "{{.Repository}}" | grep -q "^${IMAGE_NAME}$"; then
    # Image exists as-is (full path like ds01-1001/my-project)
    :
elif [[ ! "$IMAGE_NAME" =~ ^ds01- ]]; then
    # Add DS01 prefix: ds01-{user-id}/{project}
    IMAGE_NAME="ds01-${USER_ID}/${IMAGE_NAME}"
    if ! docker images --format "{{.Repository}}" | grep -q "^${IMAGE_NAME}$"; then
        # Image doesn't exist, show error
        echo -e "${RED}âœ— Image '$IMAGE_NAME' not found${NC}\n"
        echo "Available images:"
        echo ""
        # Use image-list command to show available images properly
        if command -v image-list &> /dev/null; then
            image-list 2>/dev/null || docker images --format "  {{.Repository}}" | grep "^ds01-$USER_ID/"
        else
            docker images --format "  {{.Repository}}" | grep "^ds01-$USER_ID/"
        fi
        echo ""
        echo -e "Create new image with: ${GREEN}image-create${NC}"
        exit 1
    fi
fi

# Find Dockerfile
DOCKERFILE=""

# Check info file first (sanitize filename - replace / with _)
METADATA_FILE=$(echo "$IMAGE_NAME" | tr '/' '_')
INFO_FILE="$HOME/ds01-config/images/${METADATA_FILE}.info"
if [ -f "$INFO_FILE" ]; then
    DOCKERFILE=$(grep "^Dockerfile:" "$INFO_FILE" | cut -d: -f2- | xargs)
fi

# Fallback to standard location - extract project name from image
# If IMAGE_NAME is ds01-1001/my-project, PROJECT_NAME is my-project
PROJECT_NAME="${IMAGE_NAME##*/}"
if [ -z "$DOCKERFILE" ] || [ ! -f "$DOCKERFILE" ]; then
    DOCKERFILE="$DOCKERFILES_DIR/${PROJECT_NAME}.Dockerfile"
fi

# Check if Dockerfile exists
if [ ! -f "$DOCKERFILE" ]; then
    echo -e "${RED}âœ— Dockerfile not found${NC}"
    echo "Expected location: $DOCKERFILE"
    echo ""
    read -p "Enter path to Dockerfile: " CUSTOM_PATH
    if [ -f "$CUSTOM_PATH" ]; then
        DOCKERFILE="$CUSTOM_PATH"
    else
        echo -e "${RED}âœ— File not found: $CUSTOM_PATH${NC}"
        exit 1
    fi
fi

echo ""
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BOLD}Updating Dockerfile for Image: ${CYAN}$IMAGE_NAME${NC}"
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo -e "Dockerfile: ${BLUE}$DOCKERFILE${NC}"
echo ""

# Show current image info
CURRENT_SIZE=$(docker images --format "{{.Size}}" "$IMAGE_NAME" | head -1)
CURRENT_CREATED=$(docker images --format "{{.CreatedAt}}" "$IMAGE_NAME" | head -1)

echo -e "${BOLD}Current image:${NC}"
echo "  Size:    $CURRENT_SIZE"
echo "  Created: $CURRENT_CREATED"

# Handle different modes
if [ "$EDIT_FIRST" = true ]; then
    # Advanced mode: direct edit
    echo ""
    EDITOR_CMD=$(find_editor)
    if [ "$EDITOR_CMD" = "cat" ]; then
        echo -e "${RED}âœ— No text editor found${NC}"
        echo ""
        echo "Please install one of: vim, vi, nano, emacs"
        echo "Or set EDITOR environment variable to your preferred editor"
        echo ""
        exit 1
    fi
    echo -e "${YELLOW}Opening Dockerfile in $EDITOR_CMD...${NC}"
    "$EDITOR_CMD" "$DOCKERFILE"
    echo ""

elif [ -n "$QUICK_ADD_PACKAGES" ]; then
    # Quick mode: add packages from command line
    echo ""
    echo -e "${CYAN}Quick Add Mode${NC}"
    echo ""
    echo -e "${BOLD}Adding Python packages:${NC}"
    echo ""
    add_python_packages "$DOCKERFILE" $QUICK_ADD_PACKAGES
    if [ "$PACKAGES_ADDED_COUNT" -gt 0 ]; then
        echo ""
        echo -e "${GREEN}âœ“${NC} $PACKAGES_ADDED_COUNT package(s) added to Dockerfile"
    fi
    echo ""

elif [ -n "$QUICK_ADD_SYSTEM" ]; then
    # Quick mode: add system packages from command line
    echo ""
    echo -e "${CYAN}Quick Add Mode${NC}"
    echo ""
    echo -e "${BOLD}Adding system packages:${NC}"
    echo ""
    add_system_packages "$DOCKERFILE" $QUICK_ADD_SYSTEM
    echo ""

elif [ "$GUIDED" = true ]; then
    # Guided mode: educational
    guided_mode "$DOCKERFILE"

else
    # Default: interactive mode
    interactive_mode "$DOCKERFILE"
fi

# Phase 1: Dockerfile Updated âœ“
echo ""
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${GREEN}${BOLD}âœ“ Phase 1/3: Dockerfile Updated${NC}"
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo -e "Location: ${BLUE}$DOCKERFILE${NC}"
echo ""

# Phase 2: Rebuild Image?
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BOLD}Phase 2/3: Rebuild Docker Image?${NC}"
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo "This will rebuild the image with your changes."
if [ "$NO_CACHE" = true ]; then
    echo -e "${YELLOW}âš  Building without cache (clean rebuild)${NC}"
fi
echo ""
echo -e "${DIM}Time estimate: 3-5 minutes${NC}"
echo ""
read -p "Rebuild image now? [Y/n]: " REBUILD_CONFIRM </dev/tty
REBUILD_CONFIRM=${REBUILD_CONFIRM:-Y}
echo ""

if [[ ! "$REBUILD_CONFIRM" =~ ^[Yy]$ ]]; then
    echo "Rebuild skipped."
    echo ""
    echo "Your Dockerfile has been updated."
    echo "Rebuild later with:"
    echo -e "  ${GREEN}image-update $IMAGE_NAME${NC}"
    echo ""

    # Remove backup since changes were intentional
    rm -f "${DOCKERFILE}.bak"
    exit 0
fi

# Build command with user setup build args (required for DS01 user/group creation)
BUILD_CMD="docker build"
BUILD_CMD="$BUILD_CMD --build-arg DS01_USER_ID=$USER_ID"
BUILD_CMD="$BUILD_CMD --build-arg DS01_GROUP_ID=$GROUP_ID"
BUILD_CMD="$BUILD_CMD --build-arg DS01_USERNAME=$SANITIZED_USERNAME"
BUILD_CMD="$BUILD_CMD -t $IMAGE_NAME:latest -f $DOCKERFILE"
if [ "$NO_CACHE" = true ]; then
    BUILD_CMD="$BUILD_CMD --no-cache"
fi
# Use Dockerfile directory as build context
BUILD_CMD="$BUILD_CMD $(dirname "$DOCKERFILE")/"

echo ""
echo -e "${CYAN}Building image...${NC}"
echo ""

# Build
if eval "$BUILD_CMD"; then
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}${BOLD}âœ“ Phase 2/3: Docker Image Rebuilt${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""

    # Remove backup
    rm -f "${DOCKERFILE}.bak"

    # Show new image info
    NEW_SIZE=$(docker images --format "{{.Size}}" "$IMAGE_NAME" | head -1)
    NEW_CREATED=$(docker images --format "{{.CreatedAt}}" "$IMAGE_NAME" | head -1)

    echo -e "${BOLD}Updated image:${NC}"
    echo "  Size:    $NEW_SIZE"
    echo "  Created: $NEW_CREATED"
    echo ""

    # Show what changed in the Dockerfile
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Updated Dockerfile Packages${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""

    # AIME base image (from FROM line)
    base_image=$(grep "^FROM " "$DOCKERFILE" | head -1 | sed 's/FROM //')
    if [ -n "$base_image" ]; then
        echo -e "  ${BOLD}AIME base image:${NC} ${GREEN}$base_image${NC}"
    fi

    # System packages
    sys_pkgs=$(parse_system_packages "$DOCKERFILE" | tr '\n' ' ')
    if [ -n "$sys_pkgs" ]; then
        echo -e "  ${BOLD}System:${NC} $sys_pkgs"
    else
        echo -e "  ${BOLD}System:${NC} ${DIM}(none)${NC}"
    fi

    # Parse categorized Python packages
    core_pkgs=""
    usecase_pkgs=""
    custom_pkgs=""

    while IFS=: read -r category pkg; do
        case "$category" in
            core) core_pkgs="$core_pkgs $pkg" ;;
            usecase) usecase_pkgs="$usecase_pkgs $pkg" ;;
            custom) custom_pkgs="$custom_pkgs $pkg" ;;
        esac
    done < <(parse_python_packages_by_category "$DOCKERFILE")

    # Display Python packages by category
    if [ -n "$core_pkgs" ]; then
        echo -e "  ${BOLD}Core Python:${NC}$core_pkgs"
    else
        echo -e "  ${BOLD}Core Python:${NC} ${DIM}(none)${NC}"
    fi

    if [ -n "$usecase_pkgs" ]; then
        echo -e "  ${BOLD}Pre-installed for use case:${NC}$usecase_pkgs"
    else
        echo -e "  ${BOLD}Pre-installed for use case:${NC} ${DIM}(none)${NC}"
    fi

    if [ -n "$custom_pkgs" ]; then
        echo -e "  ${BOLD}Custom-installed:${NC}$custom_pkgs"
    else
        echo -e "  ${BOLD}Custom-installed:${NC} ${DIM}(none)${NC}"
    fi
    echo ""

    # Update metadata
    if [ -f "$INFO_FILE" ]; then
        sed -i.bak "s/^Created:.*/Created: $(date)/" "$INFO_FILE"
        rm -f "${INFO_FILE}.bak"
    fi

    # Check for containers using this image
    # Extract project name from image (ds01-1001/my-project â†’ my-project)
    CONTAINER_BASE_NAME="${IMAGE_NAME##*/}"
    CONTAINER_BASE_NAME="${CONTAINER_BASE_NAME%-image}"  # Remove -image suffix if present
    FULL_CONTAINER_NAME="$CONTAINER_BASE_NAME._.$(id -u)"

    # Phase 3: Recreate Container?
    if docker ps -a --format "{{.Names}}" | grep -q "^${FULL_CONTAINER_NAME}$"; then
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BOLD}Phase 3/3: Recreate Container?${NC}"
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo "Your image has been updated, but your container is still"
        echo "using the old image. To use the new packages, you need to"
        echo "recreate and deploy the container based on the updated image."
        echo ""
        echo -e "${YELLOW}âš ${NC} This will:"
        echo "  â€¢ Stop the current container"
        echo "  â€¢ Remove the old container"
        echo "  â€¢ Create a new container from the updated image"
        echo "  â€¢ Your workspace files will be preserved"
        echo ""
        read -p "Recreate container now? [Y/n]: " RECREATE_CONFIRM </dev/tty
        RECREATE_CONFIRM=${RECREATE_CONFIRM:-Y}

        if [[ "$RECREATE_CONFIRM" =~ ^[Yy]$ ]]; then
            echo ""
            echo -e "${CYAN}Recreating container...${NC}"
            echo ""

            # Stop container if running
            if docker ps --format "{{.Names}}" | grep -q "^${FULL_CONTAINER_NAME}$"; then
                echo -e "  ${DIM}Stopping container...${NC}"
                docker stop "$FULL_CONTAINER_NAME" >/dev/null 2>&1
            fi

            # Remove old container
            echo -e "  ${DIM}Removing old container...${NC}"
            docker rm "$FULL_CONTAINER_NAME" >/dev/null 2>&1

            # Deploy new container
            echo -e "  ${DIM}Deploying new container...${NC}"
            echo ""
            if command -v container-deploy &>/dev/null; then
                container-deploy "$CONTAINER_BASE_NAME" --background
                echo ""
                echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                echo -e "${GREEN}${BOLD}âœ“ Phase 3/3: Container Deployed${NC}"
                echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                echo ""
                echo -e "${BOLD}All Done!${NC}"
                echo ""
                echo -e "Your container is running with the updated image."
            else
                echo -e "${RED}âœ— container-deploy command not found${NC}"
                echo "Please deploy the container manually."
            fi
        else
            echo ""
            echo "Skipped container recreation."
            echo ""
            echo "To redeploy manually later:"
            echo ""
            echo -e "  ${BOLD}1.${NC} Retire the old container:"
            echo -e "     ${GREEN}container-retire $CONTAINER_BASE_NAME${NC}"
            echo ""
            echo -e "  ${BOLD}2.${NC} Deploy new container from updated image:"
            echo -e "     ${GREEN}container-deploy $CONTAINER_BASE_NAME${NC}"
        fi
    else
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BOLD}Next Steps: Deploy Container${NC}"
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo "Your image is ready! Deploy a container to use it:"
        echo ""
        echo -e "  ${GREEN}container-deploy $CONTAINER_BASE_NAME${NC}"
    fi
    echo ""

else
    echo ""
    echo -e "${RED}âœ— Build failed${NC}"
    echo ""
    echo "Troubleshooting:"
    echo -e "  1. Check Dockerfile syntax: ${BLUE}cat $DOCKERFILE${NC}"
    echo -e "  2. View backup: ${BLUE}cat ${DOCKERFILE}.bak${NC}"
    echo -e "  3. Restore backup: ${GREEN}mv ${DOCKERFILE}.bak $DOCKERFILE${NC}"
    echo -e "  4. Try again: ${GREEN}image-update $IMAGE_NAME${NC}"
    echo ""
    exit 1
fi

echo ""
