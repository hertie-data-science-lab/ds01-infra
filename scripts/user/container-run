#!/bin/bash
# DS01 Container Run - L2 Atomic Command
# Starts and attaches to containers via mlc-open
# Can be used standalone or called by orchestrators

set -e

# Script paths
SCRIPT_DIR="/opt/ds01-infra/scripts/user"
INFRA_ROOT="/opt/ds01-infra"
MLC_OPEN="$INFRA_ROOT/aime-ml-containers/mlc-open"
RESOURCE_PARSER="$INFRA_ROOT/scripts/docker/get_resource_limits.py"

# Source DS01 context library for conditional output
if [[ -f "/opt/ds01-infra/scripts/lib/ds01-context.sh" ]]; then
    source /opt/ds01-infra/scripts/lib/ds01-context.sh
fi

# Source interactive library
if [ -f "/usr/local/lib/interactive-select.sh" ]; then
    source /usr/local/lib/interactive-select.sh
elif [ -f "$INFRA_ROOT/scripts/lib/interactive-select.sh" ]; then
    source "$INFRA_ROOT/scripts/lib/interactive-select.sh"
else
    echo "Error: interactive-select.sh not found"
    exit 1
fi

# Colors
BLUE='\033[94m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

USERNAME=$(whoami)
USER_ID=$(id -u)

# Helper function to get user's resource limits
get_user_lifecycle_limits() {
    local username="$1"
    if [ ! -f "$RESOURCE_PARSER" ]; then
        echo "None|None|None"
        return
    fi

    local idle_timeout=$(python3 "$RESOURCE_PARSER" "$username" --idle-timeout 2>/dev/null || echo "None")
    local max_runtime=$(python3 "$RESOURCE_PARSER" "$username" --max-runtime 2>/dev/null || echo "None")
    local gpu_hold=$(python3 "$RESOURCE_PARSER" "$username" --gpu-hold-time 2>/dev/null || echo "None")

    echo "${idle_timeout}|${max_runtime}|${gpu_hold}"
}

usage() {
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Select a Container to Run${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${CYAN}Usage:${NC}"
    echo "  container-run [name] [options]"
    echo "  container-run                    # Prompts to select container (if none specified)"
    echo ""
    echo -e "${CYAN}Arguments:${NC}"
    echo "  name              Container name (optional - will prompt if not provided)"
    echo ""
    echo -e "${CYAN}Options:${NC}"
    echo "  --guided          Show detailed explanations for beginners"
    echo "  -h, --help        Show this help message"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo -e "  ${DIM}# Start and enter container${NC}"
    echo "  container-run my-project"
    echo ""
    echo -e "  ${DIM}# With guided explanations${NC}"
    echo "  container-run my-project --guided"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ Inside the container:${NC}"
    echo -e "  â€¢ Your workspace: ${CYAN}/workspace${NC}"
    echo -e "  â€¢ Start Jupyter: ${GREEN}jlab${NC}"
    echo -e "  â€¢ Check GPU: ${GREEN}gpu${NC}"
    echo -e "  â€¢ Exit session: ${GREEN}exit${NC} (you'll choose: keep running or retire)"
    echo ""
}

# Parse arguments
CONTAINER_NAME=""
GUIDED=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --guided)
            GUIDED=true
            shift
            ;;
        -h|--help|--info)
            usage
            exit 0
            ;;
        -*)
            echo -e "${RED}âœ— Unknown option: $1${NC}\n"
            usage
            exit 1
            ;;
        *)
            if [ -z "$CONTAINER_NAME" ]; then
                CONTAINER_NAME="$1"
            else
                echo -e "${RED}âœ— Too many arguments${NC}\n"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Show guided introduction BEFORE selection
if [ "$GUIDED" = true ] && [ -z "$CONTAINER_NAME" ]; then
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Running a Container${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${BOLD}What's About to Happen:${NC}"
    echo ""
    echo "  You're about to select a container to enter via your container's bash shell."
    echo "  This is like SSH-ing into your computing environment."
    echo ""
    echo -e "${BOLD}Inside the Container:${NC}"
    echo ""
    echo -e "  Your workspace is at: ${CYAN}/workspace${NC}"
    echo "  â€¢ All your project files are there"
    echo "  â€¢ You have Python, PyTorch/TensorFlow, and GPU access"
    echo "  â€¢ You can run scripts, start Jupyter, train models, etc."
    echo ""
    echo -e "${BOLD}Helpful Commands Inside:${NC}"
    echo ""
    echo -e "  ${GREEN}gpu${NC}          Check GPU status (nvidia-smi)"
    echo -e "  ${GREEN}jlab${NC}         Start Jupyter Lab"
    echo -e "  ${GREEN}ws${NC}           Go to /workspace"
    echo -e "  ${GREEN}ll${NC}           List files"
    echo -e "  ${GREEN}exit-help${NC}    Show exit options"
    echo ""
    read -p "Press Enter to continue..." </dev/tty
    echo ""
fi

if [ "$GUIDED" = false ]; then
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}Container Run Command${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
fi

# If no container name provided, prompt to select
if [ -z "$CONTAINER_NAME" ]; then
    CONTAINER_NAME=$(select_container)
    if [ -z "$CONTAINER_NAME" ]; then
        echo "No selection made. Exiting."
        exit 0
    fi
    echo ""
fi

# Validate container name
if [ -z "$CONTAINER_NAME" ]; then
    echo -e "${RED}âœ— Container name required${NC}\n"
    usage
    exit 1
fi

# Container tag (how docker sees it)
CONTAINER_TAG="${CONTAINER_NAME}._.${USER_ID}"

# Check if container exists
if ! docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_TAG}$"; then
    echo -e "${RED}âœ— Container '$CONTAINER_NAME' does not exist${NC}"
    echo ""
    echo -e "${YELLOW}Create it first:${NC}"
    echo -e "  ${GREEN}container-create $CONTAINER_NAME${NC}"
    echo ""
    echo -e "${YELLOW}Or list your containers:${NC}"
    echo -e "  ${GREEN}container-list${NC}"
    echo ""
    exit 1
fi

# Show IDE access info (after container selection)
if [ "$GUIDED" = true ]; then
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}    âœ] How to Exit: âœ]${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "  ${YELLOW}Important: When you exit, you'll choose what happens!${NC}"
    echo ""
    echo -e "  ${BOLD}Exiting the Container:${NC}"
    echo -e "    â€¢ Type ${GREEN}exit${NC} or press ${GREEN}Ctrl+D${NC}"
    echo "    â€¢ Your bash session ends"
    echo -e "    â€¢ You'll be prompted with 2 options:"
    echo ""
    echo -e "  ${BOLD}Option 1: Keep Running${NC}"
    echo -e "    â€¢ ${CYAN}Container stays running in background${NC}"
    echo "    â€¢ GPU remains allocated to you"
    echo "    â€¢ You can reconnect anytime"
    echo -e "    â€¢ ${BOLD}Use this for: ongoing training, keeping environment ready${NC}"
    echo ""
    echo -e "  ${BOLD}Option 2: Retire Container${NC}"
    echo "    â€¢ Stop and remove container"
    echo "    â€¢ GPU freed immediately for others"
    echo "    â€¢ Workspace files remain safe"
    echo -e "    â€¢ ${BOLD}Use this when: done with task, being a good citizen!${NC}"
    echo ""

    # Show user's specific lifecycle limits
    IFS='|' read -r idle_timeout max_runtime gpu_hold <<< "$(get_user_lifecycle_limits "$USERNAME")"

    echo -e "${BOLD}Your Resource Limits:${NC}"
    echo ""
    if [ "$idle_timeout" != "None" ] && [ "$idle_timeout" != "null" ]; then
        echo -e "  â€¢ ${CYAN}Idle timeout:${NC} $idle_timeout (auto-stop after GPU idle)"
    else
        echo -e "  â€¢ ${CYAN}Idle timeout:${NC} None (no auto-stop)"
    fi

    if [ "$max_runtime" != "None" ] && [ "$max_runtime" != "null" ]; then
        echo -e "  â€¢ ${CYAN}Max runtime:${NC} $max_runtime (container auto-retires at this limit)"
    fi

    echo ""
    echo -e "${YELLOW}ğŸ’¡ Remember:${NC} Your files in /workspace are ${BOLD}always safe${NC}"
    echo "   Retiring doesn't delete your files - only the container instance!"
    echo ""
    read -p "Press Enter to continue..." </dev/tty
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}ğŸš€ IDE ACCESS: Connect to Container (VS Code)${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo "If you want to connect to Container via your IDE (here: VS Code),"
    echo "follow these steps AFTER you've run the Container:"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ Prerequisite:${NC}"
    echo -e "   - you have the ${BOLD}Dev Containers Extension${NC} installed in your local IDE."
    echo ""
    echo -e "${BOLD}1. Connect IDE to ${CYAN}ds01${NC}:${NC}"
    echo -e "   NB: this needs to be done through your IDE not via terminal SSH."
    echo ""
    echo -e "${BOLD}2. Attach IDE to the Container:${NC}"
    echo -e "   a) Open the ${BOLD}Command Pallete${NC} (Ctrl+Shift+P or Cmd+Shift+P)"
    echo -e "   b) Select: ${GREEN}Dev Containers: Attach to Running Container...${NC}"
    echo ""
    echo -e "(OR, use Dev Containers GUI on far left tab, looks like a cargo container!)"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    read -p "Press Enter to enter the container..." </dev/tty
    echo ""
fi

# Show lifecycle limits for non-guided mode
if [ "$GUIDED" = false ]; then
    IFS='|' read -r idle_timeout max_runtime gpu_hold <<< "$(get_user_lifecycle_limits "$USERNAME")"

    LIMIT_PARTS=()
    if [ "$idle_timeout" != "None" ] && [ "$idle_timeout" != "null" ]; then
        LIMIT_PARTS+=("idle timeout: $idle_timeout")
    fi
    if [ "$max_runtime" != "None" ] && [ "$max_runtime" != "null" ]; then
        LIMIT_PARTS+=("max runtime: $max_runtime")
    fi
    if [ "$gpu_hold" != "None" ] && [ "$gpu_hold" != "null" ] && [ "$gpu_hold" != "indefinite" ]; then
        LIMIT_PARTS+=("GPU hold: $gpu_hold")
    fi

    if [ ${#LIMIT_PARTS[@]} -gt 0 ]; then
        echo -e "${DIM}Your limits: $(IFS=', '; echo "${LIMIT_PARTS[*]}")${NC}"
        echo ""
    fi
fi

# Check GPU availability before starting (2c: Resource allocation validation)
GPU_ALLOCATOR="$INFRA_ROOT/scripts/docker/gpu-allocator-smart.py"
if [ -f "$GPU_ALLOCATOR" ]; then
    # Get container's allocated GPU from metadata
    CONTAINER_TAG="${CONTAINER_NAME}._.${USER_ID}"
    METADATA_FILE="/var/lib/ds01/container-metadata/${CONTAINER_TAG}.json"

    if [ -f "$METADATA_FILE" ]; then
        # Extract allocated GPU from metadata
        ALLOCATED_GPU=$(grep -o '"allocated_gpu": *"[^"]*"' "$METADATA_FILE" 2>/dev/null | cut -d'"' -f4)

        if [ -n "$ALLOCATED_GPU" ] && [ "$ALLOCATED_GPU" != "null" ]; then
            # Check if this GPU is still available/accessible
            # Use nvidia-smi to verify GPU exists and is accessible
            if [[ "$ALLOCATED_GPU" == *":"* ]]; then
                # MIG instance (format: "0:1")
                GPU_ID=$(echo "$ALLOCATED_GPU" | cut -d':' -f1)
            else
                # Full GPU
                GPU_ID="$ALLOCATED_GPU"
            fi

            # Verify GPU is accessible
            if ! nvidia-smi -i "$GPU_ID" &>/dev/null; then
                echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                echo -e "${RED}${BOLD}    âš  Resource Allocation Problem${NC}"
                echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                echo ""
                echo -e "${BOLD}This container was allocated GPU:${NC} $ALLOCATED_GPU"
                echo "That GPU is no longer available (resource landscape changed)."
                echo ""
                echo -e "${BOLD}Solution:${NC} Recreate container with fresh resource allocation"
                echo ""
                echo -e "  1. Get your container's framework:"
                echo -e "     ${DIM}docker inspect ${CONTAINER_TAG} | grep -i pytorch\\|tensorflow${NC}"
                echo ""
                echo -e "  2. Remove and recreate:"
                echo -e "     ${GREEN}container-remove $CONTAINER_NAME${NC}"
                echo -e "     ${GREEN}container-create $CONTAINER_NAME <framework>${NC}"
                echo ""
                echo -e "${GREEN}âœ“${NC} Your workspace files are safe in: ${DIM}~/workspace/$CONTAINER_NAME/${NC}"
                echo ""
                exit 1
            fi
        fi
    fi
fi

# Check if container is paused and unpause if needed
CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' "$CONTAINER_TAG" 2>/dev/null || echo "")
if [ "$CONTAINER_STATUS" = "paused" ]; then
    echo -e "${YELLOW}â—‹${NC} Container is paused. Unpausing..."
    if docker unpause "$CONTAINER_TAG" > /dev/null 2>&1; then
        echo -e "${GREEN}âœ“${NC} Container unpaused"
        echo ""
    else
        echo -e "${RED}âœ—${NC} Failed to unpause container"
        exit 1
    fi
fi

# Start background keep-alive process to prevent AIME auto-stop
# This keeps container "active" so user can choose fate after exit
# Note: Existing cron jobs (enforce-max-runtime.sh) will auto-retire when max_runtime exceeded

# First, ensure container is running (start it if needed)
if ! docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_TAG}$"; then
    # Container not running, start it
    docker start "$CONTAINER_TAG" >/dev/null 2>&1 || true
    sleep 1  # Give it a moment to start
fi

# Now start keep-alive process
KEEP_ALIVE_STARTED=false
if docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_TAG}$"; then
    # Start a named sleep process that keeps container active
    # Using sleep infinity - cron jobs enforce max_runtime and auto-retire
    if docker exec -d "$CONTAINER_TAG" bash -c 'exec -a "[ds01-keep-alive]" sleep infinity' 2>/dev/null; then
        KEEP_ALIVE_STARTED=true
    fi
fi

# Check if mlc-open exists (base system)
if [ -f "$MLC_OPEN" ] && [ -x "$MLC_OPEN" ]; then
    # Use base system mlc-open
    if [ "$GUIDED" = false ]; then
        echo -e "${CYAN}Opening container '${CONTAINER_NAME}'...${NC}"
        echo ""
    fi

    # Call mlc-open (suppress verbose MLC output when in orchestrator mode)
    if [ -n "$DS01_ORCHESTRATOR" ]; then
        # Orchestrator mode: redirect MLC stderr to suppress verbose messages
        bash "$MLC_OPEN" "$CONTAINER_NAME" 2>/dev/null
        EXIT_CODE=$?
    else
        # Direct Tier 2 use: show all MLC output
        bash "$MLC_OPEN" "$CONTAINER_NAME"
        EXIT_CODE=$?
    fi

else
    # Fallback to direct docker exec (if base system not available)
    if [ "$GUIDED" = false ]; then
        echo -e "${CYAN}Opening container '${CONTAINER_NAME}'...${NC}"
        echo ""
    fi

    # Start container if not running
    if ! docker ps --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_TAG}$"; then
        docker start "$CONTAINER_TAG" >/dev/null 2>&1 || true
    fi

    # Check if ds01-init script is available
    INIT_AVAILABLE=$(docker exec "$CONTAINER_TAG" test -f /usr/local/bin/ds01-init 2>/dev/null && echo "yes" || echo "no")

    if [ "$INIT_AVAILABLE" = "yes" ]; then
        docker exec -it "$CONTAINER_TAG" /usr/local/bin/ds01-init
    else
        docker exec -it "$CONTAINER_TAG" /bin/bash
    fi
    EXIT_CODE=$?
fi

# Post-exit handling
echo ""

# Check container state
CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' "$CONTAINER_TAG" 2>/dev/null || echo "missing")

# If called from orchestrator, exit quietly (orchestrator handles messaging)
if [ -n "$DS01_ORCHESTRATOR" ]; then
    # Clean up keep-alive process before exiting
    if [ "$KEEP_ALIVE_STARTED" = true ]; then
        docker exec "$CONTAINER_TAG" pkill -f "\[ds01-keep-alive\]" 2>/dev/null || true
    fi
    exit $EXIT_CODE
fi

# Standalone mode: Interactive prompt
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BOLD}Container Session Ended${NC}"
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""

if [ "$CONTAINER_STATUS" = "running" ]; then
    echo -e "${GREEN}âœ“${NC} Container is still running with resources allocated"
    echo ""

    # Get user's lifecycle limits for context
    IFS='|' read -r idle_timeout max_runtime gpu_hold <<< "$(get_user_lifecycle_limits "$USERNAME")"

    echo -e "${BOLD}What would you like to do?${NC}"
    echo ""
    echo -e "${CYAN}1)${NC} ${BOLD}Keep running${NC} (exit session, container stays active)"
    echo "   â€¢ You can reconnect anytime"
    echo "   â€¢ GPU remains allocated to this container"
    if [ "$idle_timeout" != "None" ] && [ "$idle_timeout" != "null" ]; then
        echo "   â€¢ Will auto-stop after ${CYAN}$idle_timeout${NC} of GPU inactivity"
    fi
    if [ "$max_runtime" != "None" ] && [ "$max_runtime" != "null" ]; then
        echo "   â€¢ Max runtime: ${CYAN}$max_runtime${NC}"
    fi
    echo ""
    echo -e "${CYAN}2)${NC} ${BOLD}Retire container${NC} (stop + remove, free GPU immediately)"
    echo "   â€¢ Removes container instance"
    echo "   â€¢ GPU freed immediately for others"
    echo "   â€¢ Workspace files remain safe"
    echo "   â€¢ Can recreate anytime with: ${GREEN}container-deploy $CONTAINER_NAME${NC}"
    echo ""

    # Show guided explanation before prompt (if guided mode)
    if [ "$GUIDED" = true ]; then
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BOLD}Understanding Your Options${NC}"
        echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo -e "${BOLD}Option 1: Keep Running${NC}"
        echo "  â€¢ Container stays active in the background"
        echo "  â€¢ All processes, environments, and data preserved"
        echo "  â€¢ GPU remains allocated to you (other users cannot use it)"
        echo "  â€¢ You can reconnect anytime with same state"
        echo "  â€¢ Container will auto-retire at max runtime limit"
        echo ""
        echo -e "${BOLD}Option 2: Retire Container${NC}"
        echo "  â€¢ Stops all processes and removes container instance"
        echo "  â€¢ GPU freed immediately for other users"
        echo "  â€¢ Workspace files remain 100% safe"
        echo "  â€¢ Can recreate container from image anytime"
        echo "  â€¢ Be a good citizen - frees resources quickly!"
        echo ""
        echo -e "${YELLOW}ğŸ’¡ Think of it like:${NC}"
        echo "  Keep running = leave laptop on but close the lid"
        echo "  Retire = shut down laptop (files still on disk)"
        echo ""
        read -p "Press Enter to choose..." </dev/tty
        echo ""
    fi

    # Prompt with default to Keep running (safest - prevents accidental removal)
    read -p "Choose [1=keep, 2=retire] (default: 1): " CHOICE </dev/tty
    echo ""

    # Default to keep running if empty input
    CHOICE=${CHOICE:-1}

    case "$CHOICE" in
        1)
            echo -e "${GREEN}âœ“${NC} Container kept running"
            echo ""
            echo -e "${BOLD}Next steps:${NC}"
            echo -e "  Reconnect: ${GREEN}container-run $CONTAINER_NAME${NC}"
            echo -e "  Status:    ${GREEN}container-list${NC}"
            echo ""
            if [ "$max_runtime" != "None" ] && [ "$max_runtime" != "null" ]; then
                echo -e "${CYAN}â„¹${NC} ${DIM}Container will auto-retire at max runtime (${max_runtime})${NC}"
                echo ""
            fi
            echo -e "${YELLOW}ğŸ’¡ Tip:${NC} When completely done, ${GREEN}container-retire $CONTAINER_NAME${NC}"
            echo "   (frees GPU for others)"
            echo ""
            ;;
        2)
            echo -e "${YELLOW}Retiring container...${NC}"
            echo ""

            # Clean up keep-alive before retiring
            docker exec "$CONTAINER_TAG" pkill -f "\[ds01-keep-alive\]" 2>/dev/null || true

            # Call container-retire
            CONTAINER_RETIRE="$SCRIPT_DIR/container-retire"
            if [ -f "$CONTAINER_RETIRE" ]; then
                bash "$CONTAINER_RETIRE" "$CONTAINER_NAME" --force
            else
                echo -e "${RED}âœ—${NC} container-retire not found"
                echo "Manual cleanup: ${GREEN}container-retire $CONTAINER_NAME${NC}"
            fi
            ;;
        *)
            echo -e "${YELLOW}Invalid choice. Keeping container running (default).${NC}"
            echo ""
            echo -e "To retire later: ${GREEN}container-retire $CONTAINER_NAME${NC}"
            echo ""
            ;;
    esac
else
    # Container stopped (shouldn't happen with keep-alive, but handle it)
    echo -e "${YELLOW}âš ${NC} Container was stopped"
    echo ""
    echo -e "${BOLD}Retiring container to avoid ambiguous stopped state...${NC}"
    echo ""

    # Clean up keep-alive if still somehow running
    if [ "$KEEP_ALIVE_STARTED" = true ]; then
        docker exec "$CONTAINER_TAG" pkill -f "\[ds01-keep-alive\]" 2>/dev/null || true
    fi

    # Auto-retire to follow "running or removed" principle
    CONTAINER_RETIRE="$SCRIPT_DIR/container-retire"
    if [ -f "$CONTAINER_RETIRE" ]; then
        bash "$CONTAINER_RETIRE" "$CONTAINER_NAME" --force
    fi
fi

exit $EXIT_CODE
