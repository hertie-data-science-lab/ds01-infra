---
phase: 04-comprehensive-resource-enforcement
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - scripts/docker/docker-wrapper.sh
  - scripts/system/verify-cgroup-driver.sh
  - scripts/system/deploy.sh
autonomous: true

must_haves:
  truths:
    - "Docker daemon uses systemd cgroup driver (verified at deploy time)"
    - "Docker wrapper checks per-user aggregate resource usage before allowing container creation"
    - "Container creation blocked with clear message when user would exceed aggregate CPU or memory quota"
    - "Admin users bypass aggregate checks"
  artifacts:
    - path: "scripts/system/verify-cgroup-driver.sh"
      provides: "Docker cgroup driver verification (fail-fast if cgroupfs)"
      min_lines: 20
    - path: "scripts/docker/docker-wrapper.sh"
      provides: "Aggregate resource quota check before container creation"
      contains: "aggregate"
  key_links:
    - from: "scripts/docker/docker-wrapper.sh"
      to: "scripts/docker/get_resource_limits.py"
      via: "calls --aggregate to get user limits"
      pattern: "--aggregate"
    - from: "scripts/docker/docker-wrapper.sh"
      to: "/sys/fs/cgroup/"
      via: "reads cgroup stats for current usage"
      pattern: "memory.current\\|cpu.stat"
    - from: "scripts/system/deploy.sh"
      to: "scripts/system/verify-cgroup-driver.sh"
      via: "calls during deployment"
      pattern: "verify-cgroup-driver"
---

<objective>
Add pre-creation aggregate quota checks to the Docker wrapper and verify Docker uses systemd cgroup driver.

Purpose: The Docker wrapper is the universal enforcement point — every container creation passes through it. Adding aggregate checks here ensures no user can exceed their total CPU/memory allocation regardless of how they launch containers. The cgroup driver check ensures containers actually land in systemd slices.

Output: Updated Docker wrapper with aggregate quota enforcement, cgroup driver verification script, deploy.sh integration.
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-comprehensive-resource-enforcement/04-CONTEXT.md
@.planning/phases/04-comprehensive-resource-enforcement/04-01-SUMMARY.md
@scripts/docker/docker-wrapper.sh
@scripts/docker/get_resource_limits.py
@scripts/system/deploy.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cgroup driver verification and add aggregate quota check to Docker wrapper</name>
  <files>
    scripts/system/verify-cgroup-driver.sh
    scripts/docker/docker-wrapper.sh
    scripts/system/deploy.sh
  </files>
  <action>
1. **Create scripts/system/verify-cgroup-driver.sh** — A small script that:
   - Checks `docker info --format '{{.CgroupDriver}}'`
   - If result is "systemd": exit 0 (success)
   - If result is "cgroupfs" or anything else: print clear error message explaining that DS01 requires systemd cgroup driver, print instructions to fix (`"exec-opts": ["native.cgroupdriver=systemd"]` in /etc/docker/daemon.json), exit 1
   - Also verify cgroup v2 is available: check if `/sys/fs/cgroup/cgroup.controllers` exists. If not, warn (but don't fail — might be hybrid mode)
   - Requires Docker daemon running (handle case where it's not with clear message)
   - This is a verification script, not an auto-configuration script (per CONTEXT.md, Claude's discretion chose fail-fast)

2. **Update deploy.sh** — Call `verify-cgroup-driver.sh` early in the deployment (after root check, before deploying commands). If it fails, print warning but continue deployment (other things may still be useful). Add symlink for `ds01-verify-cgroup` pointing to the script.

3. **Update docker-wrapper.sh** — Add a pre-creation aggregate quota check in the container creation section (after detecting container type, before GPU allocation). The check should:

   a. Be placed INSIDE the `needs_cgroup_injection` block, right after `ensure_user_slice` and before the GPU request handling section.

   b. Add a new function `check_aggregate_quota()` that:
      - Takes username as argument
      - Calls `python3 $RESOURCE_PARSER "$username" --aggregate` to get aggregate limits JSON
      - If aggregate limits are null (admin), return 0 (pass)
      - Reads current memory usage from the user's slice cgroup:
        `/sys/fs/cgroup/ds01.slice/ds01-{group}-{sanitized_user}.slice/memory.current`
      - Reads current pids count from:
        `/sys/fs/cgroup/ds01.slice/ds01-{group}-{sanitized_user}.slice/pids.current`
      - Compares against limits from the aggregate config
      - Memory check: if current memory + requested container memory > aggregate memory_max, block
      - Pids check: if current pids > 90% of tasks_max, warn (soft check)
      - Note: CPU quota is enforced by systemd kernel-level, so no pre-check needed (just log)
      - On failure: show clear message with current usage vs limit, suggest running `check-limits`
      - Returns 0 (allow) or 1 (deny)
      - FAIL-OPEN: If cgroup files don't exist or can't be read, log warning and allow (never block due to infrastructure issues)

   c. The requested container memory should be extracted from the Docker args (look for `--memory` or `--memory=` flag). If not specified, use the per-container default from resource-limits.yaml for the user's group.

   d. Add the call right before GPU allocation:
      ```bash
      # Check aggregate resource quota
      if ! check_aggregate_quota "$CURRENT_USER"; then
          exit 1
      fi
      ```

   e. Ensure admin bypass: check `is_admin` at the start of `check_aggregate_quota` and return 0 immediately.

   f. The aggregate check function should be lightweight (< 50ms) — it reads 2 files from /sys/fs/cgroup and calls get_resource_limits.py once. Cache the aggregate limits in a variable to avoid calling Python twice if other checks need it later.

IMPORTANT: Preserve all existing wrapper functionality. The aggregate check is ADDITIVE — it's a new gate before the existing GPU allocation gate. Do not modify any existing functions.
  </action>
  <verify>
    - `bash -n scripts/docker/docker-wrapper.sh` (syntax check)
    - `bash -n scripts/system/verify-cgroup-driver.sh` (syntax check)
    - `grep -q "check_aggregate_quota" scripts/docker/docker-wrapper.sh`
    - `grep -q "verify-cgroup-driver" scripts/system/deploy.sh`
    - `grep -q "memory.current" scripts/docker/docker-wrapper.sh` (reads cgroup stats)
  </verify>
  <done>Docker wrapper blocks container creation when aggregate quota would be exceeded, cgroup driver verification runs during deployment</done>
</task>

</tasks>

<verification>
- Wrapper syntax valid: `bash -n scripts/docker/docker-wrapper.sh`
- Verify script syntax: `bash -n scripts/system/verify-cgroup-driver.sh`
- Aggregate check function exists: `grep -c "check_aggregate_quota" scripts/docker/docker-wrapper.sh` returns >= 2 (definition + call)
- Fail-open pattern present: `grep -q "fail-open\|FAIL.OPEN" scripts/docker/docker-wrapper.sh`
- Admin bypass: aggregate check returns immediately for admin users
</verification>

<success_criteria>
1. Docker cgroup driver verified at deploy time with clear error if wrong
2. Container creation checks current user aggregate memory usage against limit
3. Clear error message shown when quota exceeded (shows usage vs limit)
4. Admin users bypass aggregate checks
5. Fail-open: infrastructure errors (missing cgroup files) never block container creation
</success_criteria>

<output>
After completion, create `.planning/phases/04-comprehensive-resource-enforcement/04-02-SUMMARY.md`
</output>
