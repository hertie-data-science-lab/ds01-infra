---
phase: 06-lifecycle-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/runtime/resource-limits.yaml
  - config/runtime/lifecycle-exemptions.yaml
  - scripts/docker/get_resource_limits.py
autonomous: true

must_haves:
  truths:
    - "Per-group lifecycle policies (thresholds, detection window) configurable in resource-limits.yaml"
    - "Lifecycle exemptions stored in separate YAML with time-bounded expiry support"
    - "get_resource_limits.py can resolve per-group lifecycle thresholds for a given user"
    - "get_resource_limits.py can check exemption status for a user"
  artifacts:
    - path: "config/runtime/resource-limits.yaml"
      provides: "Per-group policies section with gpu_idle_threshold, cpu_idle_threshold, network_idle_threshold, idle_detection_window"
      contains: "cpu_idle_threshold"
    - path: "config/runtime/lifecycle-exemptions.yaml"
      provides: "Time-bounded exemption records with exempt_from, expires_on, reason fields"
      contains: "exemptions"
    - path: "scripts/docker/get_resource_limits.py"
      provides: "CLI flags --lifecycle-policies and --check-exemption for lifecycle config resolution"
      exports: ["get_lifecycle_policies", "check_exemption"]
  key_links:
    - from: "scripts/docker/get_resource_limits.py"
      to: "config/runtime/resource-limits.yaml"
      via: "Per-group policies resolution"
      pattern: "policies.*idle_threshold"
    - from: "scripts/docker/get_resource_limits.py"
      to: "config/runtime/lifecycle-exemptions.yaml"
      via: "Exemption file loading and expiry checking"
      pattern: "lifecycle-exemptions"
---

<objective>
Extend the configuration schema to support per-group lifecycle policies and time-bounded exemptions.

Purpose: Phase 5 built lifecycle enforcement with global thresholds. Phase 6 needs per-group thresholds (different research groups have different workload patterns) and time-bounded exemptions (temporary research grants). This plan creates the configuration foundation that Plans 02 and 03 will consume.

Output: Extended resource-limits.yaml with per-group `policies` sub-sections, new lifecycle-exemptions.yaml file, and get_resource_limits.py methods to resolve per-group thresholds and check exemption status.
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-lifecycle-enhancements/06-RESEARCH.md
@config/runtime/resource-limits.yaml
@scripts/docker/get_resource_limits.py
@config/runtime/user-overrides.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend resource-limits.yaml with per-group lifecycle policies</name>
  <files>config/runtime/resource-limits.yaml</files>
  <action>
Add a `policies` sub-section under each group in `groups:` that overrides the global `policies:` section values. This follows the existing pattern where groups override defaults.

**Tuning rationale (LIFE-06):** CPU idle threshold tuned from <1% to 2-5% range. Per-group values: students get 2% (bursty but shorter jobs), researchers/faculty get 3% (data-heavy workflows with longer preprocessing). These are starting values — admin can tune further by editing the YAML.

**Add to each group:**

```yaml
groups:
  student:
    # ...existing fields...
    policies:
      gpu_idle_threshold: 5          # GPU util % below which GPU is idle
      cpu_idle_threshold: 2.0        # CPU util % below which CPU is idle (was hardcoded 1.0)
      network_idle_threshold: 1048576  # Network I/O bytes below which network is idle (1MB)
      idle_detection_window: 3       # Consecutive idle checks before action

  researcher:
    # ...existing fields...
    policies:
      gpu_idle_threshold: 5
      cpu_idle_threshold: 3.0        # More lenient for data-heavy workflows
      network_idle_threshold: 1048576
      idle_detection_window: 4       # More patient — 4 consecutive checks

  faculty:
    # ...existing fields...
    policies:
      gpu_idle_threshold: 5
      cpu_idle_threshold: 3.0
      network_idle_threshold: 1048576
      idle_detection_window: 4

  admin:
    # ...existing fields...
    # (admin keeps global defaults — no per-group policies needed)
```

**Update the global `policies:` section** to add the new threshold defaults:

```yaml
policies:
  # ...existing fields...
  cpu_idle_threshold: 2.0           # Default: 2% CPU (was hardcoded 1.0 in Phase 5)
  network_idle_threshold: 1048576   # Default: 1MB network I/O
  idle_detection_window: 3          # Default: 3 consecutive idle checks before action
```

**Also add `sigterm_grace_seconds` to `container_types:` for variable timeout:**

```yaml
container_types:
  devcontainer:
    # ...existing fields...
    sigterm_grace_seconds: 30       # Dev containers: K8s default

  compose:
    # ...existing fields...
    sigterm_grace_seconds: 45       # Compose: middle ground

  docker:
    # ...existing fields...
    sigterm_grace_seconds: 60       # Direct docker: full minute (likely GPU)

  unknown:
    # ...existing fields...
    sigterm_grace_seconds: 30       # Unknown: K8s default
```

Do NOT remove any existing fields. Only add new ones. Keep existing comments.
  </action>
  <verify>
Run: `python3 -c "import yaml; c=yaml.safe_load(open('config/runtime/resource-limits.yaml')); assert 'cpu_idle_threshold' in c['policies']; assert 'policies' in c['groups']['student']; assert c['groups']['student']['policies']['cpu_idle_threshold'] == 2.0; assert 'sigterm_grace_seconds' in c['container_types']['devcontainer']; print('OK')"` from /opt/ds01-infra
  </verify>
  <done>
resource-limits.yaml has per-group `policies` sections with gpu_idle_threshold, cpu_idle_threshold, network_idle_threshold, idle_detection_window; global `policies` section has new defaults; container_types have sigterm_grace_seconds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lifecycle-exemptions.yaml and extend get_resource_limits.py</name>
  <files>config/runtime/lifecycle-exemptions.yaml, scripts/docker/get_resource_limits.py</files>
  <action>
**Part A: Create `config/runtime/lifecycle-exemptions.yaml`**

Create a new file following the Azure Policy exemption pattern from research. Include one real exemption (Silke Kaiser, who is currently exempt via user-overrides.yaml) and one commented example:

```yaml
# DS01 Lifecycle Exemptions
# /opt/ds01-infra/config/runtime/lifecycle-exemptions.yaml
#
# Time-bounded exemptions from lifecycle enforcement (idle timeout, max runtime).
# Exempt users are NOT subject to enforcement but STILL receive informational warnings.
#
# Pattern: Azure Policy exemptions — records preserved after expiry for audit trail.
# Changes take effect at next cron cycle (eventual consistency, ~1 hour max).
#
# Fields:
#   username:      Login username (must match /home/<username>)
#   exempt_from:   List of enforcements to exempt: idle_timeout, max_runtime
#   reason:        Human-readable justification
#   approved_by:   Who approved (admin username)
#   approved_on:   ISO 8601 date when approved
#   expires_on:    ISO 8601 datetime for expiry (null = permanent)
#   category:      "research_grant" or "waiver"
#
# Lifecycle:
#   - Before expiry: exemption honored, user not subject to enforcement
#   - After expiry: exemption no longer honored, record preserved for audit
#   - Cleanup: optional periodic cleanup of expired records older than 90 days

exemptions:
  - username: "204214@hertie-school.lan"
    category: "waiver"
    exempt_from:
      - idle_timeout
      - max_runtime
    reason: "Pre-existing research workflow — continuous model training"
    approved_by: "datasciencelab"
    approved_on: "2026-02-14"
    expires_on: null  # Permanent exemption

  # Example: time-bounded research grant
  # - username: "alice@hertie-school.lan"
  #   category: "research_grant"
  #   exempt_from:
  #     - idle_timeout
  #     - max_runtime
  #   reason: "PhD thesis — deep learning model training"
  #   approved_by: "faculty_supervisor"
  #   approved_on: "2026-02-14"
  #   expires_on: "2026-06-30T23:59:59Z"
```

**Part B: Extend `get_resource_limits.py` with two new capabilities:**

1. **`get_lifecycle_policies(username)` method** on ResourceLimitParser:
   - Resolves lifecycle policies for a user with inheritance: global `policies` → group `policies` → user override
   - Returns dict with keys: gpu_idle_threshold, cpu_idle_threshold, network_idle_threshold, idle_detection_window, sigterm_grace_seconds
   - Group policies override global; user overrides (if they have a `policies` sub-section) override group.

2. **`check_exemption(username, enforcement_type)` method** on ResourceLimitParser:
   - Loads `lifecycle-exemptions.yaml` from same config directory
   - Checks if user has an active (non-expired) exemption for the given enforcement_type ('idle_timeout' or 'max_runtime')
   - Returns tuple: (is_exempt: bool, reason: str | None)
   - Uses `datetime.fromisoformat()` for expiry parsing (handle Z suffix)
   - If file doesn't exist, return (False, None) — no exemptions

3. **CLI flags:**
   - `--lifecycle-policies` — prints JSON of resolved lifecycle policies for user
   - `--check-exemption idle_timeout` or `--check-exemption max_runtime` — prints "exempt: <reason>" or "not_exempt"

Keep all existing methods and CLI flags unchanged. Add the new methods after `get_lifecycle_limits_json()`. Add CLI handling in the existing `main()` function.
  </action>
  <verify>
From /opt/ds01-infra, run:
1. `python3 -c "import yaml; yaml.safe_load(open('config/runtime/lifecycle-exemptions.yaml'))"`
2. `python3 scripts/docker/get_resource_limits.py someuser --lifecycle-policies` — should return JSON with cpu_idle_threshold, gpu_idle_threshold, etc.
3. `python3 scripts/docker/get_resource_limits.py '204214@hertie-school.lan' --check-exemption idle_timeout` — should print "exempt: ..."
4. `python3 scripts/docker/get_resource_limits.py someuser --check-exemption idle_timeout` — should print "not_exempt"
  </verify>
  <done>
lifecycle-exemptions.yaml exists with Azure Policy-style exemption records. get_resource_limits.py has get_lifecycle_policies() returning per-group-resolved thresholds and check_exemption() returning time-bounded exemption status. Both accessible via CLI flags.
  </done>
</task>

</tasks>

<verification>
1. YAML syntax valid: `python3 -c "import yaml; yaml.safe_load(open('config/runtime/resource-limits.yaml')); yaml.safe_load(open('config/runtime/lifecycle-exemptions.yaml'))"`
2. Per-group policies exist: `python3 -c "import yaml; c=yaml.safe_load(open('config/runtime/resource-limits.yaml')); assert all('policies' in c['groups'][g] for g in ['student','researcher','faculty'])"`
3. Lifecycle policies resolve for user: `python3 scripts/docker/get_resource_limits.py someuser --lifecycle-policies`
4. Exemption check works: `python3 scripts/docker/get_resource_limits.py '204214@hertie-school.lan' --check-exemption idle_timeout`
5. Existing CLI flags still work: `python3 scripts/docker/get_resource_limits.py someuser --idle-timeout`
</verification>

<success_criteria>
- resource-limits.yaml extended with per-group policies (thresholds + detection window)
- lifecycle-exemptions.yaml created with time-bounded exemption support
- get_resource_limits.py resolves per-group lifecycle policies with proper inheritance
- get_resource_limits.py checks exemption status with expiry handling
- All existing functionality unchanged (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/06-lifecycle-enhancements/06-01-SUMMARY.md`
</output>
