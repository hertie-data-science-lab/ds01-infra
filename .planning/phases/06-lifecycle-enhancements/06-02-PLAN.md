---
phase: 06-lifecycle-enhancements
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - scripts/monitoring/check-idle-containers.sh
  - scripts/maintenance/enforce-max-runtime.sh
autonomous: true

must_haves:
  truths:
    - "Idle detection uses per-group thresholds (CPU, GPU, network) resolved from config"
    - "Multi-signal AND logic: container idle only when ALL signals below group thresholds"
    - "Idle detection window: N consecutive idle checks required before action (configurable per-group)"
    - "Exempt users skip enforcement but still receive informational warnings"
    - "Max runtime enforcement skips exempt users"
    - "SIGTERM grace period varies by container type (GPU=60s, devcontainer=30s, compose=45s)"
    - "CPU idle threshold raised from hardcoded 1% to configurable 2-5% per group"
  artifacts:
    - path: "scripts/monitoring/check-idle-containers.sh"
      provides: "Per-group multi-signal idle detection with AND logic, detection window, exemption checking"
      contains: "check_exemption"
    - path: "scripts/maintenance/enforce-max-runtime.sh"
      provides: "Exemption-aware max runtime enforcement with variable SIGTERM grace"
      contains: "check_exemption"
  key_links:
    - from: "scripts/monitoring/check-idle-containers.sh"
      to: "scripts/docker/get_resource_limits.py"
      via: "--lifecycle-policies and --check-exemption CLI flags"
      pattern: "get_resource_limits.py.*--lifecycle-policies"
    - from: "scripts/maintenance/enforce-max-runtime.sh"
      to: "scripts/docker/get_resource_limits.py"
      via: "--check-exemption CLI flag"
      pattern: "get_resource_limits.py.*--check-exemption"
    - from: "scripts/monitoring/check-idle-containers.sh"
      to: "config/runtime/resource-limits.yaml"
      via: "Per-group policies section"
      pattern: "lifecycle.policies"
---

<objective>
Rewrite idle detection to use per-group multi-signal thresholds with AND logic and consecutive-check detection window, add exemption checking to both idle and max runtime enforcement, and implement variable SIGTERM grace by container type.

Note on LIFE-07: Container-stop timeout was already increased from 10s to 60s in Phase 5 (`sigterm_grace_seconds: 60` in policies, read by enforce-max-runtime.sh). This plan enhances it with variable timeouts by container type and ensures check-idle-containers.sh also reads from config rather than hardcoding.

Purpose: This is the core Phase 6 work — making lifecycle enforcement practical for real-world research workflows. Per-group thresholds reduce false positives (different groups have different patterns). AND logic prevents stopping containers during data loading (GPU idle but CPU active). Detection window prevents transient dips from triggering stops. Exemptions allow admin to grant temporary research exceptions. Variable SIGTERM grace ensures GPU containers have time to checkpoint.

Output: Updated check-idle-containers.sh and enforce-max-runtime.sh with full Phase 6 capabilities.
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-lifecycle-enhancements/06-RESEARCH.md
@.planning/phases/06-lifecycle-enhancements/06-01-SUMMARY.md
@scripts/monitoring/check-idle-containers.sh
@scripts/maintenance/enforce-max-runtime.sh
@scripts/docker/get_resource_limits.py
@config/runtime/resource-limits.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite idle detection with per-group thresholds, AND logic, detection window, and exemptions</name>
  <files>scripts/monitoring/check-idle-containers.sh</files>
  <action>
Modify `check-idle-containers.sh` with these specific changes:

**1. Add function to get per-group lifecycle policies for a user:**

```bash
# Get lifecycle policies for user (per-group resolution)
get_lifecycle_policies() {
    local username="$1"
    python3 "$INFRA_ROOT/scripts/docker/get_resource_limits.py" "$username" --lifecycle-policies
}

# Check if user is exempt from enforcement
check_exemption() {
    local username="$1"
    local enforcement_type="$2"
    python3 "$INFRA_ROOT/scripts/docker/get_resource_limits.py" "$username" --check-exemption "$enforcement_type"
}
```

**2. Replace the hardcoded CPU threshold (1.0) in `is_container_active_secondary()`:**

Change line ~269 from:
```bash
if (( $(echo "$cpu > 1.0" | bc -l) )); then
```
to use a parameter:
```bash
is_container_active_secondary() {
    local container="$1"
    local cpu_threshold="${2:-2.0}"
    local network_threshold="${3:-1048576}"
    # ...
    if (( $(echo "$cpu > $cpu_threshold" | bc -l) )); then
```

Also make the network threshold configurable in the same function. Change the hardcoded `1000000` to use `$network_threshold`.

**3. Replace `get_gpu_idle_threshold()` (global-only) with per-user resolution:**

Remove the `get_gpu_idle_threshold()` function. Instead, in `monitor_containers()` and `process_container_universal()`, use the per-user lifecycle policies.

**4. Rewrite `process_container_universal()` to:**

a. Resolve per-group lifecycle policies for the user via `get_lifecycle_policies`:
```bash
local policies_json=$(get_lifecycle_policies "$username")
local gpu_threshold=$(echo "$policies_json" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('gpu_idle_threshold', 5))")
local cpu_threshold=$(echo "$policies_json" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('cpu_idle_threshold', 2.0))")
local network_threshold=$(echo "$policies_json" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('network_idle_threshold', 1048576))")
local detection_window=$(echo "$policies_json" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('idle_detection_window', 3))")
```

b. Check exemption before enforcement:
```bash
local exemption_status=$(check_exemption "$username" "idle_timeout")
if [[ "$exemption_status" == exempt:* ]]; then
    local exempt_reason="${exemption_status#exempt: }"
    # Still warn but don't enforce
    log "Container $container (user: $username) is EXEMPT from idle timeout: $exempt_reason"
    # Send informational warning if idle (but don't stop)
    # ... (see below)
    return 0
fi
```

c. Pass per-group thresholds to `check_gpu_idle()` and `is_container_active_secondary()`:
```bash
local gpu_status=$(check_gpu_idle "$container" "$gpu_threshold")
# ...
local secondary_active=$(is_container_active_secondary "$container" "$cpu_threshold" "$network_threshold")
```

d. **Implement detection window** using the state file. Add `IDLE_STREAK` to state file tracking:
```bash
# In state file: IDLE_STREAK=0
# When container is idle, increment IDLE_STREAK
# When container is active, reset IDLE_STREAK to 0
# Only trigger warning/stop when IDLE_STREAK >= detection_window
```

State file format becomes:
```
LAST_ACTIVITY=<epoch>
LAST_CPU=0.0
WARNED=false
IDLE_STREAK=0
```

When container is idle:
```bash
# Increment idle streak
source "$state_file"
local current_streak=${IDLE_STREAK:-0}
current_streak=$((current_streak + 1))
sed -i "s/^IDLE_STREAK=.*/IDLE_STREAK=$current_streak/" "$state_file"

# Only proceed with timeout logic if streak >= detection_window
if [ "$current_streak" -lt "$detection_window" ]; then
    log "Container $container: idle streak $current_streak/$detection_window (waiting for consecutive checks)"
    return 0
fi
```

When container is active, reset streak:
```bash
sed -i "s/^IDLE_STREAK=.*/IDLE_STREAK=0/" "$state_file"
```

**5. Update `stop_idle_container()` to use variable SIGTERM grace:**

Replace the hardcoded `docker stop -t 60`:
```bash
# Get container-type-specific SIGTERM grace
local container_type=$(get_container_type "$container")
local grace_seconds=$(get_sigterm_grace "$container_type")
docker stop -t "$grace_seconds" "$container"
```

Add helper function:
```bash
get_sigterm_grace() {
    local container_type="$1"
    python3 << PYEOF
import yaml
try:
    with open("$CONFIG_FILE") as f:
        config = yaml.safe_load(f)
    # Container-type-specific grace first
    ct_config = config.get('container_types', {}).get('$container_type', {})
    grace = ct_config.get('sigterm_grace_seconds')
    if grace is not None:
        print(grace)
    else:
        # Fall back to global policy
        print(config.get('policies', {}).get('sigterm_grace_seconds', 60))
except Exception:
    print(60)
PYEOF
}
```

**6. For exempt users that ARE idle, send informational-only warning:**

Add an informational warning variant that clearly states the user is exempt:
```bash
send_informational_warning() {
    local username="$1"
    local container="$2"
    local reason="$3"

    local message="━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
IDLE CONTAINER NOTICE (FYI only — you are exempt)

Container: $container
Status: IDLE (no activity detected)
Exemption: $reason

No action will be taken — your exemption is active.
This is an informational notice only.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    notify_user "$username" "$message"
}
```

**7. Update `monitor_containers()` function:**

Remove the global `gpu_idle_threshold` variable (line ~493 `local gpu_idle_threshold=$(get_gpu_idle_threshold)`). Per-group thresholds are now resolved per-container in `process_container_universal()`.

Remove the `gpu_idle_threshold` parameter from the `process_container_universal` call (line ~583).

Keep `grace_period` and `high_demand` logic as-is (these remain global).
  </action>
  <verify>
1. `bash -n scripts/monitoring/check-idle-containers.sh` — syntax check passes
2. `grep -c 'cpu_threshold' scripts/monitoring/check-idle-containers.sh` — should find configurable CPU threshold references (not hardcoded 1.0)
3. `grep -c 'IDLE_STREAK' scripts/monitoring/check-idle-containers.sh` — should find detection window tracking
4. `grep -c 'check_exemption' scripts/monitoring/check-idle-containers.sh` — should find exemption checking
5. `grep 'docker stop -t 60' scripts/monitoring/check-idle-containers.sh` — should NOT find hardcoded 60 (now variable)
  </verify>
  <done>
check-idle-containers.sh uses per-group thresholds (GPU, CPU, network) via get_resource_limits.py, implements detection window (consecutive idle checks), checks exemptions before enforcement (exempt users get FYI-only warnings), uses variable SIGTERM grace by container type. CPU threshold raised from hardcoded 1% to configurable 2%+ per group.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add exemption checking and variable SIGTERM grace to max runtime enforcement</name>
  <files>scripts/maintenance/enforce-max-runtime.sh</files>
  <action>
Modify `enforce-max-runtime.sh` with these specific changes:

**1. Add exemption checking function (same as idle script):**

```bash
# Check if user is exempt from enforcement
check_exemption() {
    local username="$1"
    local enforcement_type="$2"
    python3 "$INFRA_ROOT/scripts/docker/get_resource_limits.py" "$username" --check-exemption "$enforcement_type"
}
```

**2. In `process_container_runtime_universal()`, add exemption check before enforcement:**

After getting the owner and container type, before calculating timeout:
```bash
# Check if user is exempt from max_runtime
local exemption_status=$(check_exemption "$username" "max_runtime")
if [[ "$exemption_status" == exempt:* ]]; then
    local exempt_reason="${exemption_status#exempt: }"
    log "Container $container (user: $username) is EXEMPT from max runtime: $exempt_reason"
    # Still log but don't enforce
    return 0
fi
```

**3. Update `stop_runtime_exceeded()` to use container-type-specific SIGTERM grace:**

Currently it reads `sigterm_grace_seconds` from global policies. Change to check container_types first, then fall back to global:

Replace the grace_seconds python3 block with:
```bash
local grace_seconds=$(python3 -c "
import yaml
import sys
try:
    with open('$CONFIG_FILE') as f:
        config = yaml.safe_load(f)
    # Container-type-specific grace first
    ct_config = config.get('container_types', {}).get('$container_type', {})
    grace = ct_config.get('sigterm_grace_seconds')
    if grace is not None:
        print(grace)
    else:
        # Fall back to global policy
        print(config.get('policies', {}).get('sigterm_grace_seconds', 60))
except Exception:
    print(60)
" 2>/dev/null || echo 60)
```

Note: `$container_type` is already available in `stop_runtime_exceeded()` — it's obtained from `get_container_type "$container"` at line ~224. If the variable scope doesn't pass through, get it again inside the function.

**4. Add exemption logging for audit:**

When an exempt container is skipped, log it for audit purposes:
```bash
if command -v log_event &>/dev/null; then
    log_event "maintenance.runtime_exempt" "$username" "enforce-max-runtime" \
        container="$container" \
        reason="$exempt_reason" || true
fi
```
  </action>
  <verify>
1. `bash -n scripts/maintenance/enforce-max-runtime.sh` — syntax check passes
2. `grep -c 'check_exemption' scripts/maintenance/enforce-max-runtime.sh` — should find exemption checking
3. `grep -c 'container_types' scripts/maintenance/enforce-max-runtime.sh` — should find container-type-specific grace lookup
4. `grep 'runtime_exempt' scripts/maintenance/enforce-max-runtime.sh` — should find audit event logging
  </verify>
  <done>
enforce-max-runtime.sh checks exemptions before enforcement (exempt users skip max_runtime entirely), uses container-type-specific SIGTERM grace period (resolves from container_types config first, falls back to global policies), logs exemption skips for audit trail.
  </done>
</task>

</tasks>

<verification>
1. Both scripts pass bash syntax check: `bash -n scripts/monitoring/check-idle-containers.sh && bash -n scripts/maintenance/enforce-max-runtime.sh`
2. No hardcoded CPU threshold of 1.0: `! grep '> 1\.0' scripts/monitoring/check-idle-containers.sh`
3. No hardcoded `docker stop -t 60`: `! grep 'docker stop -t 60' scripts/monitoring/check-idle-containers.sh`
4. Detection window tracking exists: `grep 'IDLE_STREAK' scripts/monitoring/check-idle-containers.sh`
5. Exemption checking in both scripts: `grep 'check_exemption' scripts/monitoring/check-idle-containers.sh scripts/maintenance/enforce-max-runtime.sh`
6. Per-group policy resolution: `grep 'lifecycle-policies\|lifecycle_policies' scripts/monitoring/check-idle-containers.sh`
</verification>

<success_criteria>
- Idle detection uses per-group thresholds (not global-only) for GPU, CPU, and network signals
- AND logic: container idle only when ALL signals below their respective per-group thresholds
- Detection window: configurable consecutive idle checks required before action (per-group)
- CPU threshold raised from hardcoded 1% to configurable 2%+ (per group defaults set in Plan 01)
- Exempt users skip enforcement but receive informational warnings (FYI only)
- Max runtime enforcement skips exempt users with audit logging
- SIGTERM grace varies by container type (GPU=60s, devcontainer=30s, compose=45s)
- All changes backward compatible — scripts still work if new config fields are missing (safe defaults)
</success_criteria>

<output>
After completion, create `.planning/phases/06-lifecycle-enhancements/06-02-SUMMARY.md`
</output>
