---
phase: 03.2-architecture-audit-code-quality
plan: 03
type: execute
wave: 2
depends_on: ["03.2-01"]
files_modified:
  - config/deploy/
  - config/runtime/
  - config/state/
  - config/variables.env
  - config/README.md
  - config/CLAUDE.md
  - scripts/system/deploy.sh
autonomous: true

must_haves:
  truths:
    - "Config files organised into deploy/ + runtime/ + state/ hierarchy with clear lifecycle separation"
    - "config/etc-mirrors/ eliminated -- its contents absorbed into deploy/ or documented as not needed"
    - "Generative config pipeline works: templates + variables.env produce correct deployed configs"
    - "deploy.sh updated to use new config structure and generative templates"
    - "All existing deploy.sh functionality preserved -- no regressions"
  artifacts:
    - path: "config/variables.env"
      provides: "Single source for deploy-time variables (user lists, paths, environment settings)"
    - path: "config/runtime/"
      provides: "Runtime configuration directory (resource-limits.yaml, exemptions)"
    - path: "config/deploy/"
      provides: "Install-time configs (systemd, profile.d, logrotate, cron)"
    - path: "config/state/"
      provides: "Persistent state directories definition (grants, rate-limits)"
    - path: "config/README.md"
      provides: "Documentation of config structure, lifecycle, and template usage"
  key_links:
    - from: "config/variables.env"
      to: "scripts/system/deploy.sh"
      via: "deploy.sh sources variables.env and calls fill_config_template()"
      pattern: "source.*variables\\.env"
    - from: "config/deploy/"
      to: "/etc/ (deployed targets)"
      via: "deploy.sh copies/generates from deploy/ to /etc/"
      pattern: "fill_config_template|cp.*config/deploy"
---

<objective>
Consolidate config/deploy/ and config/etc-mirrors/ into a single-source-of-truth hierarchy: deploy/ (install-time), runtime/ (per-operation), state/ (persistent data). Implement generative config pipeline with templates + variables.env for deploy-time substitution. Eliminate duplication of user lists, paths, and environment-specific values.

Purpose: Replace config sprawl with a clean, documented, lifecycle-based config structure. Eliminates duplication that causes out-of-sync bugs. Prepares config foundation for Phase 4 resource enforcement integration.

Output: Reorganised config/ directory with generative pipeline, updated deploy.sh, and config README.md.
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.2-architecture-audit-code-quality/03.2-CONTEXT.md
@.planning/phases/03.2-architecture-audit-code-quality/03.2-01-SUMMARY.md
@config/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit Current Config + Design Target Structure</name>
  <files>config/ (all subdirectories)</files>
  <action>
Before moving files, understand what exists and design the target:

1. **Inventory current config:**
   - List all files in `config/deploy/`, `config/etc-mirrors/`, `config/state/`
   - Identify duplicates between deploy/ and etc-mirrors/ (especially profile.d scripts)
   - Identify which etc-mirrors/ files are reference copies vs actively deployed
   - Check which files are already in runtime/ (resource-limits.yaml, etc.)

2. **Identify duplicated data:**
   - User lists (exempt users, admin users) -- grep across all config files
   - Paths (INFRA_ROOT, STATE_DIR, LOG_DIR) -- grep for /opt/ds01-infra, /var/lib/ds01, /var/log/ds01
   - Environment-specific values -- anything that would change between servers

3. **Design target structure:**
   ```
   config/
   ├── deploy/              # Install-time (deployed TO /etc/)
   │   ├── systemd/         # Service units, timers
   │   ├── profile.d/       # Environment setup scripts (may include .template files)
   │   ├── logrotate.d/     # Log rotation rules
   │   ├── cron.d/          # Scheduled jobs
   │   ├── docker/          # Docker daemon config
   │   ├── modprobe.d/      # Kernel module config
   │   └── wrappers/        # Wrapper scripts deployed to /usr/local/bin/
   ├── runtime/             # Per-operation configs (read during execution)
   │   ├── resource-limits.yaml
   │   ├── group-overrides.txt (or similar)
   │   └── user-overrides.yaml (or similar)
   ├── state/               # Persistent data directories
   │   ├── bare-metal-grants/
   │   ├── rate-limits/
   │   └── logs/
   ├── variables.env        # Deploy-time variables
   └── README.md            # Config structure documentation
   ```

4. **Decide for each file:** migrate to deploy/, runtime/, or state/? Delete (obsolete)?

Keep decisions simple. Don't over-template -- only extract to variables.env values that appear in 2+ files or are environment-specific. Don't extract immutable standards (e.g., systemd target names).
  </action>
  <verify>
Written inventory of current config with clear migration plan per file. Duplicated data identified (user lists, paths). Target structure designed.
  </verify>
  <done>Clear migration plan exists for every config file. Duplicated data identified for extraction to variables.env.</done>
</task>

<task type="auto">
  <name>Task 2: Execute Config Migration + Generative Pipeline</name>
  <files>config/, scripts/system/deploy.sh</files>
  <action>
Execute the migration plan from Task 1:

1. **Create variables.env:**
   - Extract duplicated values: exempt user lists, paths, environment settings
   - Format as bash-sourceable variables
   - Include comments explaining each variable

2. **Migrate files to target structure:**
   - Move files from etc-mirrors/ into deploy/ or runtime/ as appropriate
   - Remove etc-mirrors/ directory (or mark as deprecated if immediate removal risky)
   - Move runtime configs (resource-limits.yaml, group-overrides.txt, user-overrides.yaml) to config/runtime/
   - Ensure config/state/ has correct structure
   - Preserve config/deploy/ existing structure (systemd, profile.d, logrotate.d, cron.d)

3. **Implement generative pipeline in deploy.sh:**
   - Add `fill_config_template()` function that:
     a. Sources config/variables.env
     b. Uses envsubst to substitute variables in .template files
     c. Validates output (no unsubstituted ${VAR} remaining)
     d. Copies to target location
   - Convert 1-2 profile.d scripts to use templates (start with the one containing exempt user lists)
   - Update deploy.sh to use new config paths where they changed

4. **Add pre-deploy validation:**
   - YAML validation for resource-limits.yaml (python3 -c "import yaml; yaml.safe_load(open(...))")
   - Template validation (no unsubstituted variables after envsubst)

5. **Write config/README.md:**
   - Document the hierarchy: deploy/ vs runtime/ vs state/
   - Explain lifecycle: when each type is read
   - Document variables.env format and available variables
   - Explain template pattern (how to create new templates)
   - Include diagram of config flow

6. **Update config/CLAUDE.md** to reflect new structure.

**Important constraints:**
- All deploy.sh config path references must be updated
- All scripts that read config files must still work (check for hardcoded paths)
- Atomic commits: (a) file migration, (b) generative pipeline, (c) documentation
- Run existing tests/checks to verify no regressions
  </action>
  <verify>
- `ls config/` shows deploy/, runtime/, state/, variables.env, README.md
- `config/etc-mirrors/` is empty or removed
- `config/runtime/resource-limits.yaml` exists
- `config/variables.env` contains extracted variables
- deploy.sh sources variables.env and has fill_config_template() function
- Template substitution produces valid output (no ${VAR} remaining)
- YAML validation check works on resource-limits.yaml
- config/README.md documents the structure
  </verify>
  <done>Config consolidated into deploy/runtime/state hierarchy. Generative pipeline functional. Documentation written. deploy.sh updated. No regressions.</done>
</task>

</tasks>

<verification>
- [ ] config/etc-mirrors/ contents absorbed or documented as unnecessary
- [ ] config/runtime/ contains resource-limits.yaml and operational configs
- [ ] config/variables.env exists with deploy-time variables
- [ ] fill_config_template() function in deploy.sh works
- [ ] At least 1 profile.d script converted to template pattern
- [ ] YAML validation added to deploy.sh pre-deploy checks
- [ ] config/README.md documents the hierarchy and template pattern
- [ ] No scripts broken by config path changes (grep for old paths)
- [ ] Atomic commits for each step
</verification>

<success_criteria>
1. Single source of truth: no duplicated user lists, paths, or env-specific values across config files
2. Clear lifecycle separation: deploy/ (install), runtime/ (execution), state/ (persistence)
3. Generative pipeline: at least 1 template demonstrating the pattern for future templates
4. Documentation: README.md explains structure clearly enough for someone new to the project
5. No regressions: deploy.sh and all config consumers still work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-architecture-audit-code-quality/03.2-03-SUMMARY.md`
</output>
