---
phase: 08-user-notifications
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - scripts/monitoring/check-idle-containers.sh
  - scripts/maintenance/enforce-max-runtime.sh
autonomous: true

must_haves:
  truths:
    - "Idle containers generate two warnings: first at 80% of timeout, final at 95% of timeout"
    - "Max runtime containers generate two warnings: first at 75% of limit, final at 90% of limit"
    - "All idle and runtime notifications use the unified bordered-box template from ds01_notify.sh"
    - "Container-file fallback delivers alerts when user has no active terminals"
    - "Existing single-warning state files upgrade gracefully (WARNED_FINAL added on first run)"
  artifacts:
    - path: "scripts/monitoring/check-idle-containers.sh"
      provides: "Two-level idle escalation using ds01_notify.sh library"
      contains: "ds01_format_message"
    - path: "scripts/maintenance/enforce-max-runtime.sh"
      provides: "Two-level runtime escalation using ds01_notify.sh library"
      contains: "ds01_format_message"
  key_links:
    - from: "scripts/monitoring/check-idle-containers.sh"
      to: "scripts/lib/ds01_notify.sh"
      via: "source for notification delivery and formatting"
      pattern: "source.*ds01_notify.sh"
    - from: "scripts/maintenance/enforce-max-runtime.sh"
      to: "scripts/lib/ds01_notify.sh"
      via: "source for notification delivery and formatting"
      pattern: "source.*ds01_notify.sh"
---

<objective>
Refactor check-idle-containers.sh and enforce-max-runtime.sh to source the shared notification library and implement two-level escalating warnings.

Purpose: Replace duplicated `notify_user()` with the shared library, upgrade single-warning to two-level escalation (first heads-up + final imminent warning), and add container-file fallback for users without active terminals. Per locked decisions.

Output: Both lifecycle scripts use ds01_notify.sh for all notifications with escalating warnings.
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-user-notifications/08-RESEARCH.md
@.planning/phases/08-user-notifications/08-01-SUMMARY.md
@scripts/lib/ds01_notify.sh
@scripts/monitoring/check-idle-containers.sh
@scripts/maintenance/enforce-max-runtime.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor check-idle-containers.sh — library + two-level idle escalation</name>
  <files>scripts/monitoring/check-idle-containers.sh</files>
  <action>
**Source the library:**
- Add `source "$INFRA_ROOT/scripts/lib/ds01_notify.sh"` near the top (after existing `source` of init.sh)
- Remove the local `notify_user()` function (lines ~348-359) — now provided by library

**Upgrade send_warning() to use library formatting:**
- Replace the hardcoded message string in `send_warning()` with a call to `ds01_format_message`:
  ```bash
  local msg
  msg=$(ds01_format_message "WARNING" "IDLE CONTAINER WARNING" \
      "Container: $container
  Status: IDLE (no activity detected)
  Action: Will auto-stop in ~${minutes_until_stop} minutes
  ${high_demand_notice}
  This container will be automatically stopped to free
  resources for other users. Your work in /workspace
  is safe and will persist.

  To keep your container running:
    1. Run any command in the container
    2. Or restart your training/script

  To stop and retire now (frees GPU immediately):
    container-retire $(echo $container | cut -d'.' -f1)" \
      "$username")
  ```
- Replace `notify_user "$username" "$message"` with `ds01_notify "$username" "$container" "$msg"` (adds container fallback)

**Create send_final_warning():**
- New function similar to send_warning() but with severity "WARNING" and title "FINAL IDLE WARNING — STOPPING SOON"
- Shorter, more urgent body text emphasising imminent stop
- Calls `ds01_notify "$username" "$container" "$msg"`

**Update send_informational_warning() to use library formatting:**
- Use `ds01_format_message "NOTICE" "IDLE CONTAINER NOTICE (FYI only)" ...`
- Replace `notify_user` call with `ds01_notify "$username" "$container" "$msg"`

**Update stop_idle_container() notification to use library:**
- The stop message in stop_idle_container() (lines ~474+) should use `ds01_format_message "STOPPED" "CONTAINER AUTO-STOPPED" ...`
- Replace direct wall/notify_user call with `ds01_notify "$username" "$container" "$msg"`

**Two-level escalation in process_container_universal():**
- In the idle warning/stop logic section (lines ~769-795), add a second threshold:
  ```bash
  local warning_seconds=$((timeout_seconds * 80 / 100))     # First warning at 80%
  local final_warning_seconds=$((timeout_seconds * 95 / 100))  # Final warning at 95%
  ```
- Add WARNED_FINAL handling:
  - After the existing `if [ "$idle_seconds" -ge "$warning_seconds" ] && [ "$WARNED" != "true" ]` block
  - Add: `if [ "$idle_seconds" -ge "$final_warning_seconds" ] && [ "${WARNED_FINAL:-false}" != "true" ]`
  - Call `send_final_warning "$username" "$container" "$minutes_until_stop"`
  - Update state: `grep -q "^WARNED_FINAL=" "$state_file" && sed -i "s/^WARNED_FINAL=.*/WARNED_FINAL=true/" "$state_file" || echo "WARNED_FINAL=true" >> "$state_file"`

**State file initialisation:**
- In the state file creation block (lines ~739-747), add `echo "WARNED_FINAL=false" >> "$state_file"` after the WARNED line
- In the reset block (lines ~340-344), add `sed -i "s/^WARNED_FINAL=.*/WARNED_FINAL=false/" "$state_file"` (or append if missing, using the grep+sed guard)
- For existing state files that lack WARNED_FINAL: the `${WARNED_FINAL:-false}` default handles this — first-run upgrade is automatic

**Do NOT change:**
- The idle detection logic (GPU check, secondary signals, detection window)
- The exempt user handling flow (still sends informational warning)
- The keep-alive check in stop_idle_container()
- The get_sigterm_grace() function
  </action>
  <verify>
- `bash -n scripts/monitoring/check-idle-containers.sh` — syntax check passes
- `grep -c "notify_user" scripts/monitoring/check-idle-containers.sh` returns 0 (old function removed)
- `grep -c "ds01_notify" scripts/monitoring/check-idle-containers.sh` returns >= 3 (send_warning, send_final_warning, stop notification)
- `grep -c "ds01_format_message" scripts/monitoring/check-idle-containers.sh` returns >= 3
- `grep "WARNED_FINAL" scripts/monitoring/check-idle-containers.sh` shows initialisation, check, and update
- `grep "ds01_notify.sh" scripts/monitoring/check-idle-containers.sh` shows source line
  </verify>
  <done>
check-idle-containers.sh sources ds01_notify.sh, local notify_user() removed, all notifications use ds01_format_message + ds01_notify with container fallback, two-level escalation at 80%/95% with WARNED_FINAL state tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor enforce-max-runtime.sh — library + two-level runtime escalation</name>
  <files>scripts/maintenance/enforce-max-runtime.sh</files>
  <action>
**Source the library:**
- Add `source "$INFRA_ROOT/scripts/lib/ds01_notify.sh"` near the top (after init.sh source)
- Remove the local `notify_user()` function (lines ~41-52) — now provided by library

**Upgrade send_warning() to use library formatting:**
- Replace the hardcoded wall message in `send_warning()` (lines ~193+) with:
  ```bash
  local msg
  msg=$(ds01_format_message "WARNING" "MAX RUNTIME WARNING" \
      "Container: $container
  Status: Will auto-stop in ~${hours_until_stop} hours
  Reason: Maximum runtime limit approaching

  Please save your work and consider:
    1. Saving model checkpoints
    2. Pushing code to git
    3. Creating a new container if needed

  To check your limits: check-limits" \
      "$username")
  ds01_notify "$username" "$container" "$msg"
  ```

**Create send_final_warning():**
- New function with severity "WARNING" and title "FINAL RUNTIME WARNING — STOPPING SOON"
- More urgent body text emphasising imminent stop, save work now
- Calls `ds01_notify "$username" "$container" "$msg"`

**Update stop notification to use library:**
- The stop_runtime_exceeded() function's notification should use `ds01_format_message "STOPPED" "CONTAINER STOPPED — RUNTIME LIMIT" ...`
- Replace wall/notify call with `ds01_notify "$username" "$container" "$msg"`

**Two-level escalation in process_container():**
- Current single threshold is at 90% (line ~420): `local warning_seconds=$((runtime_seconds * 90 / 100))`
- Change to two thresholds:
  ```bash
  local warning_seconds=$((runtime_seconds * 75 / 100))       # First warning at 75%
  local final_warning_seconds=$((runtime_seconds * 90 / 100))  # Final warning at 90%
  ```
- Add WARNED_FINAL handling:
  - State file init (line ~412): add `echo "WARNED_FINAL=false" >> "$state_file"` (currently only writes WARNED=false)
  - After the existing warning check, add final warning check:
    ```bash
    if [ "$runtime_seconds_actual" -ge "$final_warning_seconds" ] && [ "${WARNED_FINAL:-false}" != "true" ]; then
        local hours_until_stop=$(( (runtime_seconds - runtime_seconds_actual) / 3600 ))
        [ "$hours_until_stop" -lt 1 ] && hours_until_stop=1
        send_final_warning "$username" "$container" "$hours_until_stop"
        grep -q "^WARNED_FINAL=" "$state_file" && sed -i "s/^WARNED_FINAL=.*/WARNED_FINAL=true/" "$state_file" || echo "WARNED_FINAL=true" >> "$state_file"
    fi
    ```

**Do NOT change:**
- The container type detection logic
- The runtime calculation
- The exempt user handling
- The SIGTERM grace period logic
  </action>
  <verify>
- `bash -n scripts/maintenance/enforce-max-runtime.sh` — syntax check passes
- `grep -c "notify_user" scripts/maintenance/enforce-max-runtime.sh` returns 0 (old function removed)
- `grep -c "ds01_notify" scripts/maintenance/enforce-max-runtime.sh` returns >= 2
- `grep -c "ds01_format_message" scripts/maintenance/enforce-max-runtime.sh` returns >= 2
- `grep "WARNED_FINAL" scripts/maintenance/enforce-max-runtime.sh` shows initialisation and check
- `grep "75 / 100" scripts/maintenance/enforce-max-runtime.sh` confirms first warning at 75%
- `grep "90 / 100" scripts/maintenance/enforce-max-runtime.sh` confirms final warning at 90%
  </verify>
  <done>
enforce-max-runtime.sh sources ds01_notify.sh, local notify_user() removed, all notifications use ds01_format_message + ds01_notify with container fallback, two-level escalation at 75%/90% with WARNED_FINAL state tracking.
  </done>
</task>

</tasks>

<verification>
- Both scripts pass `bash -n` syntax check
- Neither script contains a local `notify_user()` definition
- Both source `ds01_notify.sh`
- Both use `ds01_format_message` for all user-facing messages
- Both implement two-level escalation with WARNED_FINAL state
- Idle thresholds: 80% + 95%; Runtime thresholds: 75% + 90%
</verification>

<success_criteria>
Idle and runtime lifecycle scripts use the shared notification library for all user-facing messages, with two-level escalating warnings replacing the previous single-warning approach. Container-file fallback active for users without terminals.
</success_criteria>

<output>
After completion, create `.planning/phases/08-user-notifications/08-02-SUMMARY.md`
</output>
