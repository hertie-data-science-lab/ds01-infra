---
phase: 08-user-notifications
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - scripts/monitoring/resource-alert-checker.sh
  - config/deploy/cron.d/ds01-maintenance
  - config/deploy/profile.d/ds01-quota-greeting.sh
autonomous: true

must_haves:
  truths:
    - "Users receive terminal notifications when GPU, memory, or container quota exceeds 80%"
    - "Users receive terminal notifications when GPU, memory, or container quota reaches 100%"
    - "Quota alerts repeat with 4-hour cooldown while above threshold"
    - "Quota alerts clear automatically when usage drops below threshold"
    - "Login greeting shows pending alerts from /var/lib/ds01/alerts/"
    - "Quota alert cron runs at :10 past each hour (independent of lifecycle enforcement)"
    - "Memory quota alerts detect usage via systemd cgroup slice data"
  artifacts:
    - path: "scripts/monitoring/resource-alert-checker.sh"
      provides: "GPU + memory + container quota alerts with terminal delivery and cooldown"
      contains: "ds01_notify"
    - path: "config/deploy/cron.d/ds01-maintenance"
      provides: "Hourly quota alert cron entry at :10"
      contains: "resource-alert-checker"
    - path: "config/deploy/profile.d/ds01-quota-greeting.sh"
      provides: "Login greeting with pending alerts section"
      contains: "ds01-alerts"
  key_links:
    - from: "scripts/monitoring/resource-alert-checker.sh"
      to: "scripts/lib/ds01_notify.sh"
      via: "source for terminal delivery of quota alerts"
      pattern: "source.*ds01_notify.sh"
    - from: "config/deploy/profile.d/ds01-quota-greeting.sh"
      to: "/var/lib/ds01/alerts/*.json"
      via: "reads alert JSON files for pending alerts section"
      pattern: "alerts.*json"
---

<objective>
Extend resource-alert-checker.sh with memory quota alerts, terminal delivery with cooldown, and update the login greeting to show pending alerts.

Purpose: Closes the final notification gap — quota alerts currently only write JSON files that are invisible to users unless they log in. This plan adds real-time terminal delivery (with 4-hour cooldown to avoid spam), adds memory quota detection, updates the cron schedule, and integrates pending alerts into the login greeting.

Output: Users see quota alerts in their terminal AND at login. Three resource types (GPU, memory, containers) at two tiers (80%, 100%).
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-user-notifications/08-RESEARCH.md
@.planning/phases/08-user-notifications/08-01-SUMMARY.md
@scripts/monitoring/resource-alert-checker.sh
@config/deploy/cron.d/ds01-maintenance
@config/deploy/profile.d/ds01-quota-greeting.sh
@scripts/lib/ds01_notify.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend resource-alert-checker.sh — memory alerts + terminal delivery + cooldown</name>
  <files>scripts/monitoring/resource-alert-checker.sh</files>
  <action>
**Source the notification library:**
- Add `source "$INFRA_ROOT/scripts/lib/ds01_notify.sh"` near the top (after the variable declarations)

**Add check_memory_alerts() function:**
- Follow the same pattern as `check_gpu_alerts()` and `check_container_alerts()`
- Get user's memory limit: `python3 "$RESOURCE_PARSER" "$username" --aggregate` → parse `memory_max` from JSON
  - Handle "null" or missing aggregate (admin/unlimited → return 0)
  - Parse memory_max: strip trailing "G" or "g", convert to bytes (multiply by 1073741824)
- Get current memory usage: read `/sys/fs/cgroup/ds01.slice/ds01-{group}-{sanitized_user}.slice/memory.current`
  - Group: `python3 "$RESOURCE_PARSER" "$username" --group`
  - Sanitised username: `python3 "$INFRA_ROOT/scripts/lib/username_utils.py" "$username"` (returns systemd-safe name)
  - If cgroup file doesn't exist, skip (user slice may not be active)
- Calculate percentage: `current_bytes * 100 / max_bytes`
- Alert thresholds: 80% → `memory_usage_high`, 100% → `memory_limit_reached`
- Below threshold → clear both memory alert types
- Use the same `add_alert` / `clear_alert` functions

**Add deliver_alert_to_terminal() function:**
- Signature: `deliver_alert_to_terminal <username> <alert_type> <message_body>`
- **Cooldown logic (4 hours):**
  - Read `last_notified_at` from the alert entry in the user's JSON file (Python one-liner)
  - If `last_notified_at` exists and is less than 4 hours ago, skip delivery (return 0)
- **Determine severity:** If alert_type contains "reached" → "ALERT", otherwise → "WARNING"
- **Format message:** Call `ds01_format_message "$severity" "RESOURCE QUOTA ALERT" "$message_body" "$username"`
- **Deliver:** Call `ds01_notify "$username" "" "$msg"` (empty container — quota alerts are user-level, no container fallback per research recommendation)
- **Update cooldown:** Write `last_notified_at` timestamp to the alert entry in the JSON file (Python one-liner)
- All Python calls use `2>/dev/null || true`

**Wire terminal delivery into existing check functions:**
- In `check_gpu_alerts()`: after each `add_alert` call, call `deliver_alert_to_terminal "$username" "$alert_type" "$message"`
- In `check_container_alerts()`: same pattern
- In `check_memory_alerts()`: same pattern
- **Important:** Only deliver when alert is actually fired (at/above threshold), NOT on clear

**Update check_user() to include memory:**
- Add `check_memory_alerts "$username"` to the function body

**Admin skip:**
- At the top of `check_user()`, check if user's group is "admin" (unlimited): `local group=$(python3 "$RESOURCE_PARSER" "$username" --group 2>/dev/null)`
- If group returns empty or the user has no limits (aggregate is "null"), skip the user
- This respects the locked decision: "Quota alerts only fire for users who actually have limits configured"
- Lifecycle-exempt users STILL get checked (per locked decision) — exemption only affects idle/runtime, not quotas

**Cron output cleanup:**
- Remove the `echo "Checking resource alerts..."` and similar stdout messages — cron output goes to log file, keep it quiet unless there's an actual alert
- Replace with minimal logging via the existing `log_event` function
  </action>
  <verify>
- `bash -n scripts/monitoring/resource-alert-checker.sh` — syntax check passes
- `grep -c "check_memory_alerts" scripts/monitoring/resource-alert-checker.sh` returns >= 2 (function def + call in check_user)
- `grep -c "deliver_alert_to_terminal" scripts/monitoring/resource-alert-checker.sh` returns >= 4 (function def + calls in 3 check functions)
- `grep -c "ds01_notify" scripts/monitoring/resource-alert-checker.sh` returns >= 1
- `grep "ds01_notify.sh" scripts/monitoring/resource-alert-checker.sh` shows source line
- `grep "last_notified_at" scripts/monitoring/resource-alert-checker.sh` shows cooldown logic
- `grep "memory_usage_high\|memory_limit_reached" scripts/monitoring/resource-alert-checker.sh` shows memory alert types
  </verify>
  <done>
resource-alert-checker.sh checks GPU + memory + container quotas at 80%/100% thresholds, delivers alerts to user terminals via ds01_notify with 4-hour cooldown, clears alerts when usage drops below threshold. Admin/unlimited users skipped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update cron schedule + login greeting with pending alerts</name>
  <files>
config/deploy/cron.d/ds01-maintenance
config/deploy/profile.d/ds01-quota-greeting.sh
  </files>
  <action>
**Cron schedule update (ds01-maintenance):**
- Change the resource-alert-checker.sh entry from `*/15 * * * *` (every 15 min) to `10 * * * *` (at :10 past each hour)
- This is the locked decision: ":10 of each hour" — runs after GPU cleanup (:05), before idle check (:20)
- Update the comment to reflect the new schedule: "Check resource quotas and deliver alerts (:10 past each hour)"
- The lifecycle flow comment should be updated to include: `GPU cleanup (:05) -> quota alerts (:10) -> idle check (:20) -> runtime enforce (:35) -> container cleanup (:50)`

**Login greeting update (ds01-quota-greeting.sh):**
- After the existing quota display line (before the "Useful commands" section), add a pending alerts section:

```bash
# Pending alerts from resource monitoring
_alerts_file="/var/lib/ds01/alerts/${_username}.json"
if [ -f "$_alerts_file" ]; then
    _alert_summary=$(python3 -c "
import json, sys
try:
    alerts = json.load(open('$_alerts_file'))
    if not alerts:
        sys.exit(0)
    for a in alerts:
        severity = 'ALERT' if 'reached' in a.get('type','') else 'WARNING'
        print(f'  [{severity}] {a[\"message\"]}')
except:
    pass
" 2>/dev/null)
    if [ -n "$_alert_summary" ]; then
        echo -e " ${_B}\033[0;31mPending alerts:\033[0m"
        echo "$_alert_summary"
        echo ""
    fi
fi
```

- Add `_alerts_file` and `_alert_summary` to the `unset` cleanup line at the bottom
- This is a single Python call reading the existing JSON file — no additional get_resource_limits.py calls (per research pitfall #4: don't add more Python calls at login)
- Display style: compact inline with severity prefix — keeps login fast per locked decision
  </action>
  <verify>
- `bash -n config/deploy/cron.d/ds01-maintenance` — syntax check (may warn on cron syntax but shouldn't error)
- `grep "10 \* \* \* \*.*resource-alert-checker" config/deploy/cron.d/ds01-maintenance` — hourly at :10
- `grep -v "*/15.*resource-alert" config/deploy/cron.d/ds01-maintenance` — old 15-min schedule removed
- `bash -n config/deploy/profile.d/ds01-quota-greeting.sh` — syntax check passes
- `grep "alerts_file" config/deploy/profile.d/ds01-quota-greeting.sh` — pending alerts section present
- `grep "Pending alerts" config/deploy/profile.d/ds01-quota-greeting.sh` — section header present
- `grep "_alert_summary" config/deploy/profile.d/ds01-quota-greeting.sh | grep "unset"` — cleanup includes new vars
  </verify>
  <done>
Cron runs quota alerts hourly at :10. Login greeting shows pending alerts from /var/lib/ds01/alerts/ JSON files with severity prefix. Single Python call at login — no latency regression.
  </done>
</task>

</tasks>

<verification>
- resource-alert-checker.sh passes `bash -n`, checks GPU + memory + containers, delivers to terminals with cooldown
- ds01-maintenance cron has :10 hourly entry (not */15)
- ds01-quota-greeting.sh passes `bash -n`, shows pending alerts at login
- Full lifecycle flow: :05 GPU cleanup → :10 quota alerts → :20 idle check → :35 runtime enforce → :50 container cleanup
</verification>

<success_criteria>
Users receive real-time terminal notifications for quota alerts (GPU, memory, containers) at 80% and 100% thresholds with 4-hour cooldown. Login greeting shows any pending alerts. Cron schedule updated to hourly at :10.
</success_criteria>

<output>
After completion, create `.planning/phases/08-user-notifications/08-03-SUMMARY.md`
</output>
