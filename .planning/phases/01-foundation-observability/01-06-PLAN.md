---
phase: 01-foundation-observability
plan: 06
type: execute
wave: 3
depends_on: ["01-01", "01-05"]
files_modified:
  - scripts/docker/docker-wrapper.sh
  - scripts/docker/gpu_allocator_v2.py
  - scripts/monitoring/check-idle-containers.sh
  - scripts/maintenance/enforce-max-runtime.sh
  - scripts/maintenance/cleanup-stale-gpu-allocations.sh
  - scripts/maintenance/cleanup-stale-containers.sh
autonomous: true

must_haves:
  truths:
    - "Container lifecycle events (create, start, stop, remove) are logged with user attribution when they occur"
    - "GPU allocation and release events are logged with GPU UUID and user"
    - "Maintenance actions (idle kill, runtime kill, cleanup) are logged with affected containers"
    - "Events appear in /var/log/ds01/events.jsonl and are queryable via ds01-events"
  artifacts:
    - path: "scripts/docker/docker-wrapper.sh"
      provides: "Container create events logged via ds01_events.sh"
      contains: "log_event"
    - path: "scripts/docker/gpu_allocator_v2.py"
      provides: "GPU allocate/release events logged via ds01_events"
      contains: "log_event"
    - path: "scripts/monitoring/check-idle-containers.sh"
      provides: "Idle kill events logged"
      contains: "log_event"
    - path: "scripts/maintenance/enforce-max-runtime.sh"
      provides: "Runtime kill events logged"
      contains: "log_event"
  key_links:
    - from: "scripts/docker/docker-wrapper.sh"
      to: "scripts/lib/ds01_events.sh"
      via: "source + log_event call"
      pattern: "source.*ds01_events\\.sh"
    - from: "scripts/docker/gpu_allocator_v2.py"
      to: "scripts/lib/ds01_events.py"
      via: "Python import"
      pattern: "from ds01_events import"
---

<objective>
Instrument key DS01 scripts with event logging calls to fulfil LOG-01 (container lifecycle), LOG-02 (GPU allocation), and LOG-03 (unmanaged workload detection) requirements.

Purpose: The shared logging library and query tool are built (Plans 01, 05). Now we need to actually emit events from the scripts that perform container and GPU operations. This is the "progressive instrumentation" described in CONTEXT.md — adding `log_event()` calls to existing scripts at the points where significant actions occur. Events are best-effort (never block operations).

Output: Modified scripts with log_event() calls at container lifecycle points, GPU allocation/release points, and maintenance action points.
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-observability/01-CONTEXT.md
@.planning/phases/01-foundation-observability/01-RESEARCH.md
@.planning/phases/01-foundation-observability/01-01-SUMMARY.md
@.planning/phases/01-foundation-observability/01-05-SUMMARY.md
@scripts/docker/docker-wrapper.sh
@scripts/docker/gpu_allocator_v2.py
@scripts/monitoring/check-idle-containers.sh
@scripts/maintenance/enforce-max-runtime.sh
@scripts/maintenance/cleanup-stale-gpu-allocations.sh
@scripts/maintenance/cleanup-stale-containers.sh
@scripts/lib/ds01_events.py
@scripts/lib/ds01_events.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instrument Docker wrapper and GPU allocator</name>
  <files>scripts/docker/docker-wrapper.sh, scripts/docker/gpu_allocator_v2.py</files>
  <action>
Add event logging to the Docker wrapper (bash) and GPU allocator (Python).

**docker-wrapper.sh — Container creation events (LOG-01):**

1. Source the events library near the top (after existing `source` statements):
   ```bash
   source "${DS01_ROOT}/scripts/lib/ds01_events.sh"
   ```

2. Log container creation AFTER successful Docker create/run:
   ```bash
   log_event "container.create" "$CURRENT_USER" "docker-wrapper" \
       container="$CONTAINER_NAME" \
       image="$IMAGE" \
       container_type="$CONTAINER_TYPE" \
       gpu="$ALLOCATED_GPU"
   ```
   Place this after the real Docker command succeeds. Extract variable names by reading the wrapper's existing code — it already captures user, container name, image, type, and GPU allocation.

3. Log auth denials if the wrapper rejects a request:
   ```bash
   log_event "auth.denied" "$CURRENT_USER" "docker-wrapper" \
       reason="$DENIAL_REASON"
   ```

**IMPORTANT:** Read `docker-wrapper.sh` carefully first. The wrapper has complex flow with multiple code paths (GPU vs non-GPU, create vs run, etc.). Place log_event calls at the right points AFTER operations succeed. Never add logging that could break the critical path. Use the `|| true` pattern if there's any risk.

**gpu_allocator_v2.py — GPU allocation events (LOG-02):**

1. Import at the top:
   ```python
   sys.path.insert(0, str(Path(__file__).parent.parent / "lib"))
   from ds01_events import log_event
   ```

2. Log successful allocation:
   ```python
   log_event(
       "gpu.allocate",
       user=username,
       source="gpu_allocator",
       container=container_name,
       gpu_uuid=allocated_gpu,
       mig_profile=mig_profile
   )
   ```

3. Log allocation rejection:
   ```python
   log_event(
       "gpu.reject",
       user=username,
       source="gpu_allocator",
       container=container_name,
       reason=rejection_reason
   )
   ```

4. Log GPU release:
   ```python
   log_event(
       "gpu.release",
       user=username,
       source="gpu_allocator",
       container=container_name,
       gpu_uuid=released_gpu,
       reason=release_reason
   )
   ```

**IMPORTANT:** `gpu_allocator_v2.py` is the most critical script in the system. Read it thoroughly before making changes. Place log_event calls AFTER successful state mutations, never before. If the import fails (ds01_events not found), the allocator must still work — wrap the import in try/except and define a no-op log_event fallback.
  </action>
  <verify>
Check docker-wrapper.sh has logging: `grep -c "log_event" /opt/ds01-infra/scripts/docker/docker-wrapper.sh` >= 1
Check gpu_allocator_v2.py has logging: `grep -c "log_event" /opt/ds01-infra/scripts/docker/gpu_allocator_v2.py` >= 2
Check import safety: `grep "try:" /opt/ds01-infra/scripts/docker/gpu_allocator_v2.py | head -3` (should show try/except around ds01_events import)
Syntax check bash: `bash -n /opt/ds01-infra/scripts/docker/docker-wrapper.sh`
Syntax check python: `python3 -c "import ast; ast.parse(open('/opt/ds01-infra/scripts/docker/gpu_allocator_v2.py').read()); print('OK')"`
  </verify>
  <done>
- docker-wrapper.sh logs container.create events with user, container, image, type, GPU
- docker-wrapper.sh logs auth.denied events on rejection
- gpu_allocator_v2.py logs gpu.allocate, gpu.reject, gpu.release events
- Import is safely wrapped — allocator works even if ds01_events is missing
- No changes to critical control flow — logging is append-only, best-effort
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument maintenance and lifecycle scripts</name>
  <files>scripts/monitoring/check-idle-containers.sh, scripts/maintenance/enforce-max-runtime.sh, scripts/maintenance/cleanup-stale-gpu-allocations.sh, scripts/maintenance/cleanup-stale-containers.sh</files>
  <action>
Add event logging to the four cron-based lifecycle scripts.

**For each script, the pattern is identical:**

1. Source the events library near the top:
   ```bash
   source "${DS01_ROOT:-/opt/ds01-infra}/scripts/lib/ds01_events.sh"
   ```

2. Log events at the appropriate action points:

**check-idle-containers.sh (idle timeout enforcement):**
- When stopping an idle container:
  ```bash
  log_event "maintenance.idle_kill" "$CONTAINER_OWNER" "check-idle-containers" \
      container="$CONTAINER_NAME" \
      idle_duration="$IDLE_DURATION" \
      container_type="$CONTAINER_TYPE"
  ```

**enforce-max-runtime.sh (max runtime enforcement):**
- When stopping a container exceeding max runtime:
  ```bash
  log_event "maintenance.runtime_kill" "$CONTAINER_OWNER" "enforce-max-runtime" \
      container="$CONTAINER_NAME" \
      runtime="$CONTAINER_RUNTIME" \
      max_runtime="$MAX_RUNTIME"
  ```

**cleanup-stale-gpu-allocations.sh (GPU hold cleanup):**
- When releasing a stale GPU allocation:
  ```bash
  log_event "gpu.release" "$USER" "cleanup-stale-gpu" \
      container="$CONTAINER_NAME" \
      gpu_uuid="$GPU_ID" \
      reason="hold_expired"
  ```

**cleanup-stale-containers.sh (container removal):**
- When removing a stale container:
  ```bash
  log_event "container.remove" "$CONTAINER_OWNER" "cleanup-stale-containers" \
      container="$CONTAINER_NAME" \
      reason="hold_expired"
  ```

**IMPORTANT per script:**
- Read each script first to find the exact variable names used for container owner, name, GPU, runtime, etc.
- Place log_event AFTER the action (docker stop, docker rm, gpu release) succeeds
- Use `|| true` if there's any doubt about the event library being available
- These scripts run as root via cron — ensure the events file is writable by root
- These scripts use `set -e` — ensure log_event failures don't cause the script to exit (the bash wrapper handles this, but be cautious)
  </action>
  <verify>
Check each script:
- `grep -c "log_event" /opt/ds01-infra/scripts/monitoring/check-idle-containers.sh` >= 1
- `grep -c "log_event" /opt/ds01-infra/scripts/maintenance/enforce-max-runtime.sh` >= 1
- `grep -c "log_event" /opt/ds01-infra/scripts/maintenance/cleanup-stale-gpu-allocations.sh` >= 1
- `grep -c "log_event" /opt/ds01-infra/scripts/maintenance/cleanup-stale-containers.sh` >= 1

Syntax check all:
- `bash -n /opt/ds01-infra/scripts/monitoring/check-idle-containers.sh`
- `bash -n /opt/ds01-infra/scripts/maintenance/enforce-max-runtime.sh`
- `bash -n /opt/ds01-infra/scripts/maintenance/cleanup-stale-gpu-allocations.sh`
- `bash -n /opt/ds01-infra/scripts/maintenance/cleanup-stale-containers.sh`
  </verify>
  <done>
- check-idle-containers.sh logs maintenance.idle_kill events
- enforce-max-runtime.sh logs maintenance.runtime_kill events
- cleanup-stale-gpu-allocations.sh logs gpu.release events
- cleanup-stale-containers.sh logs container.remove events
- All scripts pass bash -n syntax check
- Logging is best-effort — failures don't break maintenance cron jobs
  </done>
</task>

</tasks>

<verification>
1. All scripts have log_event calls:
   ```bash
   for f in scripts/docker/docker-wrapper.sh scripts/docker/gpu_allocator_v2.py scripts/monitoring/check-idle-containers.sh scripts/maintenance/enforce-max-runtime.sh scripts/maintenance/cleanup-stale-gpu-allocations.sh scripts/maintenance/cleanup-stale-containers.sh; do echo "$f: $(grep -c log_event /opt/ds01-infra/$f)"; done
   ```
2. All bash scripts pass syntax check:
   ```bash
   for f in scripts/docker/docker-wrapper.sh scripts/monitoring/check-idle-containers.sh scripts/maintenance/enforce-max-runtime.sh scripts/maintenance/cleanup-stale-gpu-allocations.sh scripts/maintenance/cleanup-stale-containers.sh; do bash -n "/opt/ds01-infra/$f" && echo "$f: OK"; done
   ```
3. Python syntax check: `python3 -c "import ast; ast.parse(open('/opt/ds01-infra/scripts/docker/gpu_allocator_v2.py').read()); print('OK')"`
</verification>

<success_criteria>
- Container lifecycle events logged: create (via wrapper), remove (via cleanup)
- GPU events logged: allocate, reject, release (via allocator + cleanup)
- Maintenance events logged: idle_kill, runtime_kill (via cron scripts)
- All events include user attribution where available
- No script behaviour changed — logging is purely additive, best-effort
- Running `ds01-events --type container --limit 10` will show container lifecycle events after the next container operation
- Running `ds01-events --type gpu --limit 10` will show GPU events after the next allocation
- Running `ds01-events --type maintenance --limit 10` will show maintenance events after next cron run
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-observability/01-06-SUMMARY.md`
</output>
