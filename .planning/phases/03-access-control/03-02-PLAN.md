---
phase: 03-access-control
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/docker/docker-wrapper.sh
autonomous: true

must_haves:
  truths:
    - "Non-admin user running docker ps sees only their own containers"
    - "Non-admin user running docker container ls sees only their own containers"
    - "Non-admin user cannot docker exec into another user's container"
    - "Non-admin user cannot docker stop another user's container"
    - "Non-admin user cannot docker rm another user's container"
    - "Non-admin user cannot docker logs, inspect, stats, attach, top another user's container"
    - "Admin (datasciencelab or ds01-admin group) sees all containers and can manage any container"
    - "Cross-user attempts show 'Permission denied: this container belongs to <username>'"
    - "Containers without ds01.user label are treated fail-open with warning log"
    - "Unknown Docker subcommands pass through unchanged (fail-open)"
    - "Wrapper crash does not block Docker operations (fail-open with explicit error handling, NOT ERR trap)"
    - "DS01_ISOLATION_MODE=monitoring logs would-be denials but allows all operations through"
  artifacts:
    - path: "scripts/docker/docker-wrapper.sh"
      provides: "Complete container isolation enforcement"
      contains: "verify_container_ownership"
  key_links:
    - from: "scripts/docker/docker-wrapper.sh"
      to: "/usr/local/bin/docker"
      via: "deploy.sh copies wrapper to PATH"
      pattern: "REAL_DOCKER=/usr/bin/docker"
    - from: "scripts/docker/docker-wrapper.sh"
      to: "Docker labels ds01.user"
      via: "docker inspect to check ownership"
      pattern: "ds01\\.user"
---

<objective>
Expand the Docker wrapper to enforce container isolation — users can only see and manage their own containers.

Purpose: Prevent users from interfering with each other's containers (ACCESS-03, ACCESS-04, ACCESS-05). This replaces the failed OPA approach with Docker wrapper-based authorization, using the ds01.user label injected by the wrapper itself (Phase A+B+C) and detected by the Phase 2 awareness layer.

Output: Expanded docker-wrapper.sh with container list filtering, ownership verification for all container-targeting commands, admin bypass, rate-limited denial logging, and debug mode.
</objective>

<execution_context>
@/home/datasciencelab/.claude/get-shit-done/workflows/execute-plan.md
@/home/datasciencelab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-access-control/03-CONTEXT.md
@.planning/phases/03-access-control/03-RESEARCH.md
@scripts/docker/docker-wrapper.sh
@scripts/lib/ds01_events.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement container isolation in Docker wrapper</name>
  <files>scripts/docker/docker-wrapper.sh</files>
  <action>
    Expand the existing docker-wrapper.sh to add comprehensive container isolation. The wrapper already handles cgroup injection, label injection, and GPU allocation for run/create. This task adds:

    **1. Update is_admin() function:**
    Replace current is_admin() with expanded version:
    ```bash
    is_admin() {
        # Root is always admin
        [[ "$CURRENT_UID" -eq 0 ]] && return 0
        # datasciencelab is always admin
        [[ "$CURRENT_USER" == "datasciencelab" ]] && return 0
        # ds01-admin group membership
        groups "$CURRENT_USER" 2>/dev/null | grep -qE '\bds01-admin\b'
    }
    ```

    **2. Add verify_container_ownership() function:**
    ```bash
    verify_container_ownership() {
        local container="$1"
        local operation="$2"  # for logging

        # Admin bypass
        is_admin && return 0

        # Get container owner from ds01.user label
        local owner
        owner=$("$REAL_DOCKER" inspect "$container" --format '{{index .Config.Labels "ds01.user"}}' 2>/dev/null || echo "")

        # Fallback: check aime.mlc.USER label for pre-Phase-3 containers
        if [[ -z "$owner" || "$owner" == "<no value>" ]]; then
            owner=$("$REAL_DOCKER" inspect "$container" --format '{{index .Config.Labels "aime.mlc.USER"}}' 2>/dev/null || echo "")
        fi

        # No owner label at all — fail-open with warning
        if [[ -z "$owner" || "$owner" == "<no value>" ]]; then
            log_debug "WARNING: Container $container has no owner label - allowing operation (fail-open)"
            # Log warning event (best-effort)
            if command -v log_event &>/dev/null; then
                log_event "access.unowned_container" "$CURRENT_USER" "docker-wrapper" \
                    container="$container" operation="$operation" || true
            fi
            return 0
        fi

        # Check ownership
        if [[ "$owner" != "$CURRENT_USER" ]]; then
            echo "Permission denied: this container belongs to ${owner}" >&2
            # Rate-limited denial logging
            rate_limited_deny_log "$CURRENT_USER" "$operation $container" "container belongs to $owner"
            return 1
        fi

        return 0
    }
    ```

    **3. Add rate_limited_deny_log() function:**
    Rate limiting for denial events. Max 10 denials per user per hour. First denial always logged at auth.warning. State files in /var/lib/ds01/rate-limits/.

    ```bash
    rate_limited_deny_log() {
        local user="$1"
        local command="$2"
        local reason="$3"
        local now
        now=$(date +%s)
        local state_file="/var/lib/ds01/rate-limits/deny-${user}.state"

        mkdir -p /var/lib/ds01/rate-limits 2>/dev/null || true

        local count=0
        local timestamp=$now
        if [[ -f "$state_file" ]]; then
            read -r count timestamp < "$state_file" 2>/dev/null || true
            # Reset if window expired (3600s = 1 hour)
            if (( now - timestamp > 3600 )); then
                count=0
                timestamp=$now
            fi
        fi

        # First denial always logged
        if (( count == 0 )); then
            logger -p auth.warning -t ds01-access "FIRST DENIAL: user=$user command=$command reason=$reason"
        fi

        # Check limit (max 10 per hour)
        if (( count < 10 )); then
            logger -p auth.notice -t ds01-access "DENIED: user=$user command=$command reason=$reason (${count}+1/10)"
        fi

        echo "$((count + 1)) $timestamp" > "$state_file" 2>/dev/null || true

        # Log event (best-effort)
        if command -v log_event &>/dev/null; then
            log_event "auth.denied" "$user" "docker-wrapper" \
                command="$command" reason="$reason" || true
        fi
    }
    ```

    **4. Rewrite filter_container_list() — re-enable user filtering:**
    Remove the disabled comment block. Replace with active filtering:
    ```bash
    filter_container_list() {
        if is_admin; then
            log_debug "Admin pass-through for container list"
            exec "$REAL_DOCKER" "$@"
        fi

        # Non-admin: filter to show only own containers
        # Inject --filter for ds01.user label
        log_debug "Filtering container list for user=$CURRENT_USER"

        # Build filtered args — insert filter before other args
        local subcommand="$1"
        shift
        exec "$REAL_DOCKER" "$subcommand" --filter "label=ds01.user=$CURRENT_USER" "$@"
    }
    ```

    **5. Expand main() to intercept all container-targeting commands:**
    Replace the current main() function logic. The new flow:

    a. **No args** — pass through
    b. **docker ps** — filter_container_list
    c. **docker container ls|list|ps** — filter_container_list (handle all aliases)
    d. **docker run|create** — existing cgroup/label/GPU injection (unchanged)
    e. **docker exec|logs|inspect|stats|attach|top|port|diff|export|wait** — verify_container_ownership on target container, then pass through
    f. **docker stop|start|restart|pause|unpause|kill|rm|remove|rename|update** — verify_container_ownership (plus existing protected container check), then pass through
    g. **docker images|image|build|pull|push|tag|save|load|login|logout|search** — pass through (image operations unrestricted)
    h. **docker network|volume|system|context|plugin|trust|manifest|compose|buildx|scout** — pass through (not container-targeting)
    i. **Everything else** — pass through (fail-open for unknown subcommands)

    For commands in categories (e) and (f), extract the container target. The container is typically the first non-flag argument after the subcommand. Handle both `docker exec <container>` and `docker container exec <container>` forms.

    Container target extraction logic:
    ```bash
    # Extract container target from args
    # Skips flags (args starting with -) and their values
    extract_container_target() {
        local skip_next=false
        for arg in "$@"; do
            if $skip_next; then
                skip_next=false
                continue
            fi
            case "$arg" in
                -*=*) continue ;;  # --flag=value
                -*)
                    # Flags that take a value: skip next arg
                    case "$arg" in
                        -e|-w|--env|--workdir|--user|-u|--name|--label|-l|--format|-f|--filter)
                            skip_next=true ;;
                    esac
                    continue
                    ;;
                *)
                    # First non-flag arg is the container
                    echo "$arg"
                    return 0
                    ;;
            esac
        done
        return 1
    }
    ```

    **6. Add debug mode support:**
    Expand log_debug to support DS01_WRAPPER_DEBUG env var:
    - `DS01_WRAPPER_DEBUG=1`: Log interceptions (denials, filter injections, ownership checks)
    - `DS01_WRAPPER_DEBUG=2`: Log all invocations (every docker command)
    Update the existing `DEBUG_DS01_WRAPPER` check to also accept `DS01_WRAPPER_DEBUG` for consistency.

    **7. Add emergency bypass and isolation mode:**
    At the very top of main(), before any logic:
    ```bash
    # Save original args for fail-open fallback
    _ORIGINAL_ARGS=("$@")

    # Emergency bypass
    if [[ "${DS01_WRAPPER_BYPASS:-0}" == "1" ]]; then
        exec "$REAL_DOCKER" "$@"
    fi

    # Isolation mode: disabled | monitoring | full (default)
    # Deploy in monitoring mode first to verify no false positives,
    # then switch to full when confident.
    case "${DS01_ISOLATION_MODE:-full}" in
        disabled) exec "$REAL_DOCKER" "$@" ;;
        monitoring) _MONITORING_ONLY=true ;;
        *) _MONITORING_ONLY=false ;;
    esac
    ```
    When `_MONITORING_ONLY=true`, denial paths should log the would-be denial but allow the operation through instead of blocking. Specifically:
    - `verify_container_ownership()`: On ownership mismatch, log "MONITORING: would deny user=$CURRENT_USER operation=$operation container=$container owner=$owner" via logger, then return 0 instead of returning 1.
    - `filter_container_list()`: Log "MONITORING: would filter container list for user=$CURRENT_USER" then exec without filter.

    **8. Fail-open wrapper protection (explicit error handling, NOT ERR trap):**
    Do NOT use an ERR trap — it has subtle semantics and `$@` in the trap context is not the original script args. Instead:
    - Save original args at top of script: `_ORIGINAL_ARGS=("$@")` (done in step 7 above)
    - Wrap each risky function call with explicit fallback:
    ```bash
    if ! result=$(some_check 2>/dev/null); then
        logger -p daemon.err -t ds01-wrapper "Check failed - allowing operation" 2>/dev/null
        exec "$REAL_DOCKER" "${_ORIGINAL_ARGS[@]}"
    fi
    ```
    - The `DS01_WRAPPER_BYPASS` and fail-open for unknown commands are sufficient — no global trap needed.
    - Remove `set -e` from the wrapper. The wrapper must be fault-tolerant with explicit error checking.

    **Important design decisions:**
    - Do NOT use `set -e` or `set -euo pipefail` in the wrapper. The wrapper must be fault-tolerant and never block Docker operations due to its own errors.
    - Do NOT use an ERR trap for fail-open. Use explicit error handling with `_ORIGINAL_ARGS` fallback (see step 8).
    - Container target extraction is best-effort. If extraction fails, fall through to pass-through (fail-open).
    - The `docker container <subcommand>` form: parse second arg as the management subcommand, then apply same logic as top-level equivalents.
    - `docker compose` (plugin form) and `docker-compose` (standalone): pass through unchanged. Compose operations go through docker run/create for actual containers, where the wrapper already intercepts.
    - Multiple container args (e.g., `docker stop c1 c2 c3`): Check ownership of ALL containers. If any fails, deny the entire operation. This is simpler than partial execution and avoids confusing partial failures.

    **NOTE — follow-up required:** `scripts/user/atomic/container-list` calls `/usr/bin/docker` directly, bypassing the wrapper and container isolation. This is a user-facing command that needs updating to respect isolation. This is NOT in scope for this plan — it should be addressed as a follow-up task (can be added to Plan 03-03 or a separate ticket). Admin scripts that use `/usr/bin/docker` directly are correct — they need system-level visibility.

    **Do NOT change:**
    - The existing cgroup injection logic for run/create
    - The existing GPU allocation logic
    - The existing label injection logic
    - The existing protected container check (keep it, but integrate with ownership verification)
  </action>
  <verify>
    - `bash -n scripts/docker/docker-wrapper.sh` exits 0 (syntax check)
    - grep for `verify_container_ownership` returns match
    - grep for `rate_limited_deny_log` returns match
    - grep for `DS01_WRAPPER_BYPASS` returns match
    - grep for `DS01_ISOLATION_MODE` returns match (monitoring mode support)
    - grep for `_MONITORING_ONLY` returns match (monitoring mode variable)
    - grep for `_ORIGINAL_ARGS` returns match (explicit error handling fallback)
    - grep for `DS01_WRAPPER_DEBUG` returns match
    - Wrapper does NOT contain `trap.*ERR` (no ERR trap — uses explicit error handling)
    - grep for `filter_container_list` shows active filtering (not the disabled pass-through)
    - grep for `is_admin` shows datasciencelab check
    - grep for `fail-open\|fail.open` or comment about fail-open behaviour
    - The filter_container_list function contains `--filter "label=ds01.user=`
  </verify>
  <done>
    Docker wrapper enforces container isolation: docker ps filtered per user, all container-targeting commands verified for ownership, admin bypass for datasciencelab/ds01-admin, rate-limited denial logging, debug mode via DS01_WRAPPER_DEBUG, emergency bypass via DS01_WRAPPER_BYPASS, monitoring mode via DS01_ISOLATION_MODE, fail-open via explicit error handling with _ORIGINAL_ARGS fallback (no ERR trap).
  </done>
</task>

</tasks>

<verification>
1. `bash -n scripts/docker/docker-wrapper.sh` passes
2. Wrapper contains verify_container_ownership function
3. Wrapper intercepts ps, exec, logs, inspect, stats, stop, rm, kill and more
4. Admin bypass works for UID 0, datasciencelab, and ds01-admin group
5. Denial message shows "Permission denied: this container belongs to <username>"
6. Rate limiting logic present for denial events
7. Debug mode, emergency bypass, and monitoring mode (DS01_ISOLATION_MODE) env vars supported
8. Existing cgroup/label/GPU injection logic preserved
9. Unknown commands pass through (fail-open)
</verification>

<success_criteria>
- docker-wrapper.sh has container isolation enforcement
- Non-admin docker ps returns only own containers (via label filter)
- Cross-user container operations denied with helpful message
- Admin (root/datasciencelab/ds01-admin) bypasses all restrictions
- Fail-open via explicit error handling (no ERR trap) prevents wrapper from blocking Docker
- DS01_ISOLATION_MODE=monitoring mode logs but allows all operations (safe deployment path)
- Rate-limited denial logging prevents log flooding
</success_criteria>

<output>
After completion, create `.planning/phases/03-access-control/03-02-SUMMARY.md`
</output>
